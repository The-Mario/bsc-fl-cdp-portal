{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nexport function wrapContract(contract, name, abi, txManager) {\n  var nonConstantFns = {};\n\n  var _iterator = _createForOfIteratorHelper(abi),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          type = _step$value.type,\n          constant = _step$value.constant,\n          _name = _step$value.name,\n          inputs = _step$value.inputs;\n\n      if (type === 'function' && constant === false) {\n        // Map all of the contract method names + sigs in cases where the method\n        // sig is used as the key due to method overloading, e.g.\n        // contract[\"method(address,uint256)\"](foo, bar)\n        if (inputs.length > 0) {\n          var methodSig = \"\".concat(_name, \"(\").concat(inputs.map(function (i) {\n            return i.type;\n          }).join(','), \")\");\n          nonConstantFns[methodSig] = true;\n        } // Currently assume that the default method chosen by Ethers when there\n        // are multiple overloaded methods of the same name is non-constant\n\n\n        nonConstantFns[_name] = true;\n      }\n    } // Why is the first argument an almost-empty object? The functions in\n    // ethers.Contract are set up as read-only, non-configurable properties, which\n    // means if we try to change their values with Proxy, we get an error.\n    //\n    // But that only happens if the contract is specified as the first argument to\n    // Proxy. So we don't do that. Go on, wag your finger.\n    //\n    // See https://stackoverflow.com/a/48495509/56817 for more explanation.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var proxy = new Proxy({\n    // this is handy for testing, but probably shouldn't be used for anything\n    // else\n    wrappedContract: contract\n  }, {\n    get: function get(target, key) {\n      if (key in target) return target[key];\n      if (!txManager || !nonConstantFns[key]) return contract[key];\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return txManager.sendContractCall(contract, key, args, name);\n      };\n    },\n    set: function set(target, key, value) {\n      contract[key] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(wrapContract, \"wrapContract\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/smartContract/wrapContract.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/smartContract/wrapContract.js"],"names":["wrapContract","contract","name","abi","txManager","nonConstantFns","type","constant","inputs","length","methodSig","map","i","join","proxy","Proxy","wrappedContract","get","target","key","args","sendContractCall","set","value"],"mappings":";;;;;;;;;;;AAAA,OAAO,SAASA,YAAT,CAAsBC,QAAtB,EAAgCC,IAAhC,EAAsCC,GAAtC,EAA2CC,SAA3C,EAAsD;AAC3D,MAAMC,cAAc,GAAG,EAAvB;;AAD2D,6CAEdF,GAFc;AAAA;;AAAA;AAE3D,wDAAkD;AAAA;AAAA,UAAvCG,IAAuC,eAAvCA,IAAuC;AAAA,UAAjCC,QAAiC,eAAjCA,QAAiC;AAAA,UAAvBL,KAAuB,eAAvBA,IAAuB;AAAA,UAAjBM,MAAiB,eAAjBA,MAAiB;;AAChD,UAAIF,IAAI,KAAK,UAAT,IAAuBC,QAAQ,KAAK,KAAxC,EAA+C;AAC7C;AACA;AACA;AACA,YAAIC,MAAM,CAACC,MAAP,GAAgB,CAApB,EAAuB;AACrB,cAAMC,SAAS,aAAMR,KAAN,cAAcM,MAAM,CAACG,GAAP,CAAW,UAAAC,CAAC;AAAA,mBAAIA,CAAC,CAACN,IAAN;AAAA,WAAZ,EAAwBO,IAAxB,CAA6B,GAA7B,CAAd,MAAf;AACAR,UAAAA,cAAc,CAACK,SAAD,CAAd,GAA4B,IAA5B;AACD,SAP4C,CAQ7C;AACA;;;AACAL,QAAAA,cAAc,CAACH,KAAD,CAAd,GAAuB,IAAvB;AACD;AACF,KAf0D,CAiB3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxB2D;AAAA;AAAA;AAAA;AAAA;;AAyB3D,MAAMY,KAAK,GAAG,IAAIC,KAAJ,CACZ;AACE;AACA;AACAC,IAAAA,eAAe,EAAEf;AAHnB,GADY,EAMZ;AACEgB,IAAAA,GADF,eACMC,MADN,EACcC,GADd,EACmB;AACf,UAAIA,GAAG,IAAID,MAAX,EAAmB,OAAOA,MAAM,CAACC,GAAD,CAAb;AACnB,UAAI,CAACf,SAAD,IAAc,CAACC,cAAc,CAACc,GAAD,CAAjC,EAAwC,OAAOlB,QAAQ,CAACkB,GAAD,CAAf;AAExC,aAAO;AAAA,0CAAIC,IAAJ;AAAIA,UAAAA,IAAJ;AAAA;;AAAA,eACLhB,SAAS,CAACiB,gBAAV,CAA2BpB,QAA3B,EAAqCkB,GAArC,EAA0CC,IAA1C,EAAgDlB,IAAhD,CADK;AAAA,OAAP;AAED,KAPH;AASEoB,IAAAA,GATF,eASMJ,MATN,EAScC,GATd,EASmBI,KATnB,EAS0B;AACtBtB,MAAAA,QAAQ,CAACkB,GAAD,CAAR,GAAgBI,KAAhB;AACA,aAAO,IAAP;AACD;AAZH,GANY,CAAd;AAsBA,SAAOT,KAAP;AACD;;;;;;;;;;0BAhDed,Y","sourcesContent":["export function wrapContract(contract, name, abi, txManager) {\n  const nonConstantFns = {};\n  for (let { type, constant, name, inputs } of abi) {\n    if (type === 'function' && constant === false) {\n      // Map all of the contract method names + sigs in cases where the method\n      // sig is used as the key due to method overloading, e.g.\n      // contract[\"method(address,uint256)\"](foo, bar)\n      if (inputs.length > 0) {\n        const methodSig = `${name}(${inputs.map(i => i.type).join(',')})`;\n        nonConstantFns[methodSig] = true;\n      }\n      // Currently assume that the default method chosen by Ethers when there\n      // are multiple overloaded methods of the same name is non-constant\n      nonConstantFns[name] = true;\n    }\n  }\n\n  // Why is the first argument an almost-empty object? The functions in\n  // ethers.Contract are set up as read-only, non-configurable properties, which\n  // means if we try to change their values with Proxy, we get an error.\n  //\n  // But that only happens if the contract is specified as the first argument to\n  // Proxy. So we don't do that. Go on, wag your finger.\n  //\n  // See https://stackoverflow.com/a/48495509/56817 for more explanation.\n  const proxy = new Proxy(\n    {\n      // this is handy for testing, but probably shouldn't be used for anything\n      // else\n      wrappedContract: contract\n    },\n    {\n      get(target, key) {\n        if (key in target) return target[key];\n        if (!txManager || !nonConstantFns[key]) return contract[key];\n\n        return (...args) =>\n          txManager.sendContractCall(contract, key, args, name);\n      },\n\n      set(target, key, value) {\n        contract[key] = value;\n        return true;\n      }\n    }\n  );\n\n  return proxy;\n}\n"]},"metadata":{},"sourceType":"module"}