{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { PublicService } from '@makerdao/services-core';\nimport TransactionObject from './TransactionObject';\nimport { uniqueId } from '../utils';\nimport each from 'lodash/each';\nimport has from 'lodash/has';\nimport { inspect } from 'util';\nimport debug from 'debug';\nvar log = debug('dai:TransactionManager');\n\nvar TransactionManager = /*#__PURE__*/function (_PublicService) {\n  _inherits(TransactionManager, _PublicService);\n\n  var _super = _createSuper(TransactionManager);\n\n  function TransactionManager() {\n    var _this;\n\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transactionManager';\n\n    _classCallCheck(this, TransactionManager);\n\n    _this = _super.call(this, name, ['web3', 'nonce', 'proxy', 'gas']);\n    _this._newTxListeners = [];\n    _this._tracker = new Tracker();\n    return _this;\n  } // this method must not be async\n\n\n  _createClass(TransactionManager, [{\n    key: \"sendContractCall\",\n    value: function sendContractCall(contract, method, args, name) {\n      var _this2 = this;\n\n      log(\"sendContractCall: \".concat(name, \".\").concat(method, \" \").concat(inspect(args)));\n      if (!args) args = [];\n      var options,\n          promise,\n          businessObject,\n          metadata = {\n        contract: name,\n        method: method.replace(/\\(.*\\)$/g, ''),\n        args: args\n      },\n          lastArg = args[args.length - 1];\n\n      if (typeof lastArg === 'object' && lastArg.constructor === Object) {\n        options = lastArg;\n        args = args.slice(0, args.length - 1); // append additional metadata to the default values.\n\n        if (options.metadata) {\n          metadata = _objectSpread({}, metadata, {}, options.metadata);\n          delete options.metadata;\n        }\n\n        if (has(options, 'promise')) {\n          if (options.promise) promise = options.promise;\n          delete options.promise;\n        }\n\n        if (options.businessObject) {\n          businessObject = options.businessObject;\n          delete options.businessObject;\n        } // some subproviders require a value key included with the Tx\n\n\n        if (!has(options, 'value')) {\n          options.value = 0;\n        }\n      } else {\n        options = {};\n      } // for promise tracking to work, we must return to the caller the result of\n      // _createTransactionObject, because that promise is the one stored for\n      // lookup to attach lifecycle hooks.\n\n\n      return this._createTransactionObject(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var txOptions;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _this2._buildTransactionOptions(options, contract, method, args);\n\n              case 2:\n                txOptions = _context.sent;\n                return _context.abrupt(\"return\", _this2._execute(contract, method, args, txOptions));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))(), {\n        businessObject: businessObject,\n        metadata: metadata,\n        promise: promise\n      });\n    } // this method must not be async\n\n  }, {\n    key: \"sendTransaction\",\n    value: function sendTransaction(options, metadata) {\n      var _this3 = this;\n\n      return this._createTransactionObject(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var txOptions;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _this3._buildTransactionOptions(options);\n\n              case 2:\n                txOptions = _context2.sent;\n                return _context2.abrupt(\"return\", _this3.get('web3').sendTransaction(txOptions));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))(), metadata);\n    }\n  }, {\n    key: \"onNewTransaction\",\n    value: function onNewTransaction(cb) {\n      this._newTxListeners.push(cb);\n    }\n  }, {\n    key: \"onTransactionUpdate\",\n    value: function onTransactionUpdate(cb) {\n      var _this4 = this;\n\n      this._tracker._globalListeners.push(cb);\n\n      return {\n        unsub: function unsub() {\n          var idx = _this4._tracker._globalListeners.indexOf(cb);\n\n          if (idx !== -1) _this4._tracker._globalListeners.splice(idx, 1);\n        }\n      };\n    }\n  }, {\n    key: \"getTransaction\",\n    value: function getTransaction(promise, label) {\n      return this._tracker.get(uniqueId(promise), label);\n    }\n  }, {\n    key: \"confirm\",\n    value: function () {\n      var _confirm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(promise, count) {\n        var txs;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return promise;\n\n              case 2:\n                txs = this._tracker.getAll(uniqueId(promise));\n                return _context3.abrupt(\"return\", Promise.all(txs.map(function (tx) {\n                  return tx.confirm(count);\n                })));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function confirm(_x, _x2) {\n        return _confirm.apply(this, arguments);\n      }\n\n      return confirm;\n    }()\n  }, {\n    key: \"isMined\",\n    value: function isMined(promise) {\n      return this._tracker.get(uniqueId(promise)).isMined();\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(promise, handlers) {\n      if (typeof handlers === 'function') {\n        this._tracker.listen(uniqueId(promise), {\n          pending: function pending(tx) {\n            return handlers(tx, 'pending');\n          },\n          mined: function mined(tx) {\n            return handlers(tx, 'mined');\n          },\n          confirmed: function confirmed(tx) {\n            return handlers(tx, 'confirmed');\n          },\n          error: function error(tx, err) {\n            return handlers(tx, 'error', err);\n          }\n        });\n      } else {\n        this._tracker.listen(uniqueId(promise), handlers);\n      }\n    } // if options.dsProxy is set, execute this contract method through the\n    // proxy contract at that address.\n\n  }, {\n    key: \"_execute\",\n    value: function _execute(contract, method, args, options) {\n      if (!options.dsProxy) {\n        delete options.dsProxy;\n        return contract[method].apply(contract, _toConsumableArray(args).concat([options]));\n      }\n\n      var address;\n\n      if (typeof options.dsProxy === 'string') {\n        address = options.dsProxy;\n      }\n\n      delete options.dsProxy;\n      return this.get('proxy').execute(contract, method, args, options, address);\n    }\n  }, {\n    key: \"_createTransactionObject\",\n    value: function _createTransactionObject(tx) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          businessObject = _ref3.businessObject,\n          metadata = _ref3.metadata,\n          promise = _ref3.promise;\n\n      var txo = new TransactionObject(tx, this, {\n        businessObject: businessObject,\n        metadata: metadata\n      });\n\n      this._newTxListeners.forEach(function (cb) {\n        return cb(txo);\n      });\n\n      var minePromise = txo.mine(); // we store the transaction object under the unique id of its own mine\n      // promise, so that it can be looked up when calling a contract function\n      // directly from a service method, e.g. WethToken.deposit.\n\n      this._tracker.store(uniqueId(minePromise), txo); // if the `promise` object is defined in the options argument, we also store\n      // the transaction object under that promise's id, so that it can be looked\n      // up when calling a contract function indirectly via two or more nested\n      // service method calls, e.g.\n      // EthereumCdpService.lockEth -> WethToken.deposit.\n\n\n      if (promise) this._tracker.store(uniqueId(promise), txo, {\n        globalTxStateUpdates: false\n      });\n      return minePromise;\n    }\n  }, {\n    key: \"_buildTransactionOptions\",\n    value: function () {\n      var _buildTransactionOptions2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(options, contract, method, args) {\n        var txSpeed;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(contract && !options.gasLimit)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                _context4.next = 3;\n                return this._getGasLimit(options, contract, method, args);\n\n              case 3:\n                options.gasLimit = _context4.sent;\n\n              case 4:\n                if (this.get('gas').disablePrice) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                txSpeed = options.transactionSpeed;\n                _context4.next = 8;\n                return this.get('gas').getGasPrice(txSpeed);\n\n              case 8:\n                options.gasPrice = _context4.sent;\n\n              case 9:\n                _context4.t0 = _objectSpread;\n                _context4.t1 = {};\n                _context4.t2 = options;\n                _context4.t3 = {};\n                _context4.t4 = this.get('web3').transactionSettings();\n                _context4.next = 16;\n                return this.get('nonce').getNonce();\n\n              case 16:\n                _context4.t5 = _context4.sent;\n                _context4.t6 = {\n                  nonce: _context4.t5\n                };\n                return _context4.abrupt(\"return\", (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t3, _context4.t4, _context4.t6));\n\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _buildTransactionOptions(_x3, _x4, _x5, _x6) {\n        return _buildTransactionOptions2.apply(this, arguments);\n      }\n\n      return _buildTransactionOptions;\n    }()\n  }, {\n    key: \"_getGasLimit\",\n    value: function () {\n      var _getGasLimit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(options, contract, method, args) {\n        var _contract$interface$f;\n\n        var transaction, data, proxyAddress, proxy;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                transaction = {};\n                data = (_contract$interface$f = contract.interface.functions)[method].apply(_contract$interface$f, _toConsumableArray(args)).data;\n\n                if (!options.dsProxy) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                _context5.next = 5;\n                return this.get('proxy').currentProxy();\n\n              case 5:\n                proxyAddress = _context5.sent;\n                proxy = this.get('proxy').getUnwrappedProxyContract(proxyAddress);\n                data = proxy.interface.functions['execute'](contract.address, data).data;\n\n              case 8:\n                if (options.value) {\n                  transaction.value = options.value;\n                }\n\n                transaction = _objectSpread({\n                  from: this.get('web3').currentAddress(),\n                  to: options.dsProxy ? proxyAddress : contract.address,\n                  data: data\n                }, transaction);\n                return _context5.abrupt(\"return\", this.get('gas').estimateGasLimit(transaction));\n\n              case 11:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _getGasLimit(_x7, _x8, _x9, _x10) {\n        return _getGasLimit2.apply(this, arguments);\n      }\n\n      return _getGasLimit;\n    }()\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return TransactionManager;\n}(PublicService);\n\nexport { TransactionManager as default };\n\nvar Tracker = /*#__PURE__*/function () {\n  function Tracker() {\n    _classCallCheck(this, Tracker);\n\n    this._listeners = {};\n    this._globalListeners = [];\n    this._transactions = {};\n  }\n\n  _createClass(Tracker, [{\n    key: \"store\",\n    value: function store(key, tx) {\n      var _this5 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        globalTxStateUpdates: true\n      };\n\n      this._init(key);\n\n      this._transactions[key].push(tx);\n\n      var _iterator = _createForOfIteratorHelper(this.constructor.states),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var state = _step.value;\n          tx.on(state, function () {\n            if (options.globalTxStateUpdates) {\n              _this5._globalListeners.forEach(function (cb) {\n                return tx.error ? cb(tx, state, tx.error) : cb(tx, state);\n              });\n            }\n\n            _this5._listeners[key][state].forEach(function (cb) {\n              return tx.error ? cb(tx, tx.error) : cb(tx);\n            });\n          });\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (options.globalTxStateUpdates) this._globalListeners.forEach(function (cb) {\n        return cb(tx, 'initialized');\n      });\n\n      this._listeners[key].initialized.forEach(function (cb) {\n        return tx.error ? cb(tx, tx.error) : cb(tx);\n      });\n\n      this.clearExpiredTransactions();\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(key, handlers) {\n      var _this6 = this;\n\n      this._init(key);\n\n      var _loop2 = function _loop2(_state) {\n        var cb = handlers[_state];\n        if (_state === 'confirmed') _state = 'finalized';\n\n        _this6._listeners[key][_state].push(cb); // if event has already happened, call handler immediately\n\n\n        _this6._transactions[key].forEach(function (tx) {\n          return tx && tx.inOrPastState(_state) && (tx.error ? cb(tx, tx.error) : cb(tx));\n        });\n\n        state = _state;\n      };\n\n      for (var state in handlers) {\n        _loop2(state);\n      }\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll(key) {\n      return this._transactions[key];\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var txs = this._transactions[key];\n\n      if (!txs || txs.length === 0) {\n        throw new Error(\"No transactions for key \".concat(key));\n      }\n\n      if (txs.length > 1) {\n        console.warn(\"Key \".concat(key, \" matches \").concat(txs.length, \" transactions; returning the first.\"));\n      }\n\n      return txs[0];\n    }\n  }, {\n    key: \"clearExpiredTransactions\",\n    value: function clearExpiredTransactions() {\n      var _this7 = this;\n\n      each(this._transactions, function (txList, key) {\n        txList.forEach(function (tx) {\n          var txAge = (new Date().getTime() - new Date(tx._timeStampMined).getTime()) / 60000;\n\n          if ((tx.isError() || tx.isFinalized()) && txAge > 5) {\n            var indexToRemove = _this7._transactions[key].indexOf(tx);\n\n            _this7._transactions[key].splice(indexToRemove, 1);\n\n            if (_this7._transactions[key].length === 0) {\n              delete _this7._transactions[key];\n              delete _this7._listeners[key];\n            }\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(key) {\n      if (!this._transactions[key]) this._transactions[key] = [];\n\n      if (!this._listeners[key]) {\n        this._listeners[key] = this.constructor.states.reduce(function (acc, state) {\n          acc[state] = [];\n          return acc;\n        }, {});\n      }\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return Tracker;\n}();\n\nTracker.states = ['initialized', 'pending', 'mined', 'finalized', 'error'];\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(log, \"log\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/TransactionManager.js\");\n  reactHotLoader.register(TransactionManager, \"TransactionManager\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/TransactionManager.js\");\n  reactHotLoader.register(Tracker, \"Tracker\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/TransactionManager.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/TransactionManager.js"],"names":["PublicService","TransactionObject","uniqueId","each","has","inspect","debug","log","TransactionManager","name","_newTxListeners","_tracker","Tracker","contract","method","args","options","promise","businessObject","metadata","replace","lastArg","length","constructor","Object","slice","value","_createTransactionObject","_buildTransactionOptions","txOptions","_execute","get","sendTransaction","cb","push","_globalListeners","unsub","idx","indexOf","splice","label","count","txs","getAll","Promise","all","map","tx","confirm","isMined","handlers","listen","pending","mined","confirmed","error","err","dsProxy","address","execute","txo","forEach","minePromise","mine","store","globalTxStateUpdates","gasLimit","_getGasLimit","disablePrice","txSpeed","transactionSpeed","getGasPrice","gasPrice","transactionSettings","getNonce","nonce","transaction","data","interface","functions","currentProxy","proxyAddress","proxy","getUnwrappedProxyContract","from","currentAddress","to","estimateGasLimit","_listeners","_transactions","key","_init","states","state","on","initialized","clearExpiredTransactions","inOrPastState","Error","console","warn","txList","txAge","Date","getTime","_timeStampMined","isError","isFinalized","indexToRemove","reduce","acc"],"mappings":"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","sourcesContent":["import { PublicService } from '@makerdao/services-core';\nimport TransactionObject from './TransactionObject';\nimport { uniqueId } from '../utils';\nimport each from 'lodash/each';\nimport has from 'lodash/has';\nimport { inspect } from 'util';\nimport debug from 'debug';\nconst log = debug('dai:TransactionManager');\n\nexport default class TransactionManager extends PublicService {\n  constructor(name = 'transactionManager') {\n    super(name, ['web3', 'nonce', 'proxy', 'gas']);\n    this._newTxListeners = [];\n    this._tracker = new Tracker();\n  }\n\n  // this method must not be async\n  sendContractCall(contract, method, args, name) {\n    log(`sendContractCall: ${name}.${method} ${inspect(args)}`);\n    if (!args) args = [];\n    let options,\n      promise,\n      businessObject,\n      metadata = {\n        contract: name,\n        method: method.replace(/\\(.*\\)$/g, ''),\n        args\n      },\n      lastArg = args[args.length - 1];\n\n    if (typeof lastArg === 'object' && lastArg.constructor === Object) {\n      options = lastArg;\n      args = args.slice(0, args.length - 1);\n\n      // append additional metadata to the default values.\n      if (options.metadata) {\n        metadata = { ...metadata, ...options.metadata };\n        delete options.metadata;\n      }\n\n      if (has(options, 'promise')) {\n        if (options.promise) promise = options.promise;\n        delete options.promise;\n      }\n\n      if (options.businessObject) {\n        businessObject = options.businessObject;\n        delete options.businessObject;\n      }\n\n      // some subproviders require a value key included with the Tx\n      if (!has(options, 'value')) {\n        options.value = 0;\n      }\n    } else {\n      options = {};\n    }\n\n    // for promise tracking to work, we must return to the caller the result of\n    // _createTransactionObject, because that promise is the one stored for\n    // lookup to attach lifecycle hooks.\n    return this._createTransactionObject(\n      (async () => {\n        // so we do our async operations inside this immediately-executed\n        // async function.\n        const txOptions = await this._buildTransactionOptions(\n          options,\n          contract,\n          method,\n          args\n        );\n        return this._execute(contract, method, args, txOptions);\n      })(),\n      {\n        businessObject,\n        metadata,\n        promise\n      }\n    );\n  }\n\n  // this method must not be async\n  sendTransaction(options, metadata) {\n    return this._createTransactionObject(\n      (async () => {\n        const txOptions = await this._buildTransactionOptions(options);\n        return this.get('web3').sendTransaction(txOptions);\n      })(),\n      metadata\n    );\n  }\n\n  onNewTransaction(cb) {\n    this._newTxListeners.push(cb);\n  }\n\n  onTransactionUpdate(cb) {\n    this._tracker._globalListeners.push(cb);\n    return {\n      unsub: () => {\n        const idx = this._tracker._globalListeners.indexOf(cb);\n        if (idx !== -1) this._tracker._globalListeners.splice(idx, 1);\n      }\n    };\n  }\n\n  getTransaction(promise, label) {\n    return this._tracker.get(uniqueId(promise), label);\n  }\n\n  async confirm(promise, count) {\n    await promise;\n    const txs = this._tracker.getAll(uniqueId(promise));\n    return Promise.all(txs.map(tx => tx.confirm(count)));\n  }\n\n  isMined(promise) {\n    return this._tracker.get(uniqueId(promise)).isMined();\n  }\n\n  listen(promise, handlers) {\n    if (typeof handlers === 'function') {\n      this._tracker.listen(uniqueId(promise), {\n        pending: tx => handlers(tx, 'pending'),\n        mined: tx => handlers(tx, 'mined'),\n        confirmed: tx => handlers(tx, 'confirmed'),\n        error: (tx, err) => handlers(tx, 'error', err)\n      });\n    } else {\n      this._tracker.listen(uniqueId(promise), handlers);\n    }\n  }\n\n  // if options.dsProxy is set, execute this contract method through the\n  // proxy contract at that address.\n  _execute(contract, method, args, options) {\n    if (!options.dsProxy) {\n      delete options.dsProxy;\n      return contract[method](...args, options);\n    }\n\n    let address;\n    if (typeof options.dsProxy === 'string') {\n      address = options.dsProxy;\n    }\n\n    delete options.dsProxy;\n    return this.get('proxy').execute(contract, method, args, options, address);\n  }\n\n  _createTransactionObject(tx, { businessObject, metadata, promise } = {}) {\n    const txo = new TransactionObject(tx, this, {\n      businessObject,\n      metadata\n    });\n\n    this._newTxListeners.forEach(cb => cb(txo));\n\n    const minePromise = txo.mine();\n\n    // we store the transaction object under the unique id of its own mine\n    // promise, so that it can be looked up when calling a contract function\n    // directly from a service method, e.g. WethToken.deposit.\n    this._tracker.store(uniqueId(minePromise), txo);\n\n    // if the `promise` object is defined in the options argument, we also store\n    // the transaction object under that promise's id, so that it can be looked\n    // up when calling a contract function indirectly via two or more nested\n    // service method calls, e.g.\n    // EthereumCdpService.lockEth -> WethToken.deposit.\n    if (promise)\n      this._tracker.store(uniqueId(promise), txo, {\n        globalTxStateUpdates: false\n      });\n\n    return minePromise;\n  }\n\n  async _buildTransactionOptions(options, contract, method, args) {\n    if (contract && !options.gasLimit) {\n      options.gasLimit = await this._getGasLimit(\n        options,\n        contract,\n        method,\n        args\n      );\n    }\n\n    if (!this.get('gas').disablePrice) {\n      let txSpeed = options.transactionSpeed;\n      options.gasPrice = await this.get('gas').getGasPrice(txSpeed);\n    }\n\n    return {\n      ...options,\n      ...this.get('web3').transactionSettings(),\n      nonce: await this.get('nonce').getNonce()\n    };\n  }\n\n  async _getGasLimit(options, contract, method, args) {\n    let transaction = {};\n    let data = contract.interface.functions[method](...args).data;\n    let proxyAddress;\n\n    if (options.dsProxy) {\n      proxyAddress = await this.get('proxy').currentProxy();\n      const proxy = this.get('proxy').getUnwrappedProxyContract(proxyAddress);\n      data = proxy.interface.functions['execute'](contract.address, data).data;\n    }\n\n    if (options.value) {\n      transaction.value = options.value;\n    }\n\n    transaction = {\n      from: this.get('web3').currentAddress(),\n      to: options.dsProxy ? proxyAddress : contract.address,\n      data,\n      ...transaction\n    };\n\n    return this.get('gas').estimateGasLimit(transaction);\n  }\n}\n\nclass Tracker {\n  static states = ['initialized', 'pending', 'mined', 'finalized', 'error'];\n\n  constructor() {\n    this._listeners = {};\n    this._globalListeners = [];\n    this._transactions = {};\n  }\n\n  store(key, tx, options = { globalTxStateUpdates: true }) {\n    this._init(key);\n    this._transactions[key].push(tx);\n\n    for (let state of this.constructor.states) {\n      tx.on(state, () => {\n        if (options.globalTxStateUpdates) {\n          this._globalListeners.forEach(cb =>\n            tx.error ? cb(tx, state, tx.error) : cb(tx, state)\n          );\n        }\n        this._listeners[key][state].forEach(cb =>\n          tx.error ? cb(tx, tx.error) : cb(tx)\n        );\n      });\n    }\n\n    if (options.globalTxStateUpdates)\n      this._globalListeners.forEach(cb => cb(tx, 'initialized'));\n\n    this._listeners[key].initialized.forEach(cb =>\n      tx.error ? cb(tx, tx.error) : cb(tx)\n    );\n    this.clearExpiredTransactions();\n  }\n\n  listen(key, handlers) {\n    this._init(key);\n\n    for (let state in handlers) {\n      const cb = handlers[state];\n      if (state === 'confirmed') state = 'finalized';\n      this._listeners[key][state].push(cb);\n\n      // if event has already happened, call handler immediately\n      this._transactions[key].forEach(\n        tx =>\n          tx &&\n          tx.inOrPastState(state) &&\n          (tx.error ? cb(tx, tx.error) : cb(tx))\n      );\n    }\n  }\n\n  getAll(key) {\n    return this._transactions[key];\n  }\n\n  get(key) {\n    const txs = this._transactions[key];\n    if (!txs || txs.length === 0) {\n      throw new Error(`No transactions for key ${key}`);\n    }\n    if (txs.length > 1) {\n      console.warn(\n        `Key ${key} matches ${txs.length} transactions; returning the first.`\n      );\n    }\n    return txs[0];\n  }\n\n  clearExpiredTransactions() {\n    each(this._transactions, (txList, key) => {\n      txList.forEach(tx => {\n        const txAge =\n          (new Date().getTime() - new Date(tx._timeStampMined).getTime()) /\n          60000;\n        if ((tx.isError() || tx.isFinalized()) && txAge > 5) {\n          const indexToRemove = this._transactions[key].indexOf(tx);\n          this._transactions[key].splice(indexToRemove, 1);\n          if (this._transactions[key].length === 0) {\n            delete this._transactions[key];\n            delete this._listeners[key];\n          }\n        }\n      });\n    });\n  }\n\n  _init(key) {\n    if (!this._transactions[key]) this._transactions[key] = [];\n    if (!this._listeners[key]) {\n      this._listeners[key] = this.constructor.states.reduce((acc, state) => {\n        acc[state] = [];\n        return acc;\n      }, {});\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}