{"ast":null,"code":"import _regeneratorRuntime from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { promiseWait } from '../utils';\nimport TransactionLifeCycle from '../eth/TransactionLifeCycle';\nimport debug from 'debug';\nimport { ETH } from './Currency';\nvar log = debug('dai:TransactionObject');\n\nvar TransactionObject = /*#__PURE__*/function (_TransactionLifeCycle) {\n  _inherits(TransactionObject, _TransactionLifeCycle);\n\n  var _super = _createSuper(TransactionObject);\n\n  function TransactionObject(transaction, transactionManager) {\n    var _this;\n\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        businessObject = _ref.businessObject,\n        metadata = _ref.metadata;\n\n    _classCallCheck(this, TransactionObject);\n\n    _this = _super.call(this, businessObject);\n    _this._transaction = transaction;\n    _this._web3Service = transactionManager.get('web3');\n    _this._nonceService = transactionManager.get('nonce');\n    _this._timeStampSubmitted = new Date();\n    _this.metadata = metadata || {};\n    _this._confirmedBlockCount = _this._web3Service.confirmedBlockCount();\n    return _this;\n  }\n\n  _createClass(TransactionObject, [{\n    key: \"timeStampSubmitted\",\n    value: function timeStampSubmitted() {\n      return this._timeStampSubmitted;\n    }\n  }, {\n    key: \"timeStamp\",\n    value: function timeStamp() {\n      return this._timeStampMined;\n    }\n  }, {\n    key: \"fees\",\n    value: function fees() {\n      return this._fees;\n    }\n  }, {\n    key: \"mine\",\n    value: function mine() {\n      var _this2 = this;\n\n      if (!this._dataPromise) this._dataPromise = this._getTransactionData();\n      return this._dataPromise.then(function () {\n        return _this2._returnValue();\n      });\n    }\n  }, {\n    key: \"isFinalized\",\n    value: function isFinalized() {\n      if (this._blockNumberWhenMined + this._confirmedBlockCount <= this._web3Service.blockNumber()) this.setFinalized();\n      return _get(_getPrototypeOf(TransactionObject.prototype), \"isFinalized\", this).call(this);\n    }\n  }, {\n    key: \"confirm\",\n    value: function () {\n      var _confirm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var count,\n            newBlockNumber,\n            newReceipt,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                count = _args.length > 0 && _args[0] !== undefined ? _args[0] : this._confirmedBlockCount;\n                this._confirmedBlockCount = count;\n                _context.next = 4;\n                return this.mine();\n\n              case 4:\n                if (!(parseInt(count) <= 0)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 6:\n                newBlockNumber = this.receipt.blockNumber + count;\n                _context.next = 9;\n                return this._web3Service.waitForBlockNumber(newBlockNumber);\n\n              case 9:\n                _context.next = 11;\n                return this._web3Service.getTransactionReceipt(this.hash);\n\n              case 11:\n                newReceipt = _context.sent;\n\n                if (!(newReceipt.blockHash !== this.receipt.blockHash)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                throw new Error('transaction block hash changed');\n\n              case 14:\n                this.setFinalized();\n                return _context.abrupt(\"return\", this._returnValue());\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function confirm() {\n        return _confirm.apply(this, arguments);\n      }\n\n      return confirm;\n    }()\n  }, {\n    key: \"_getTransactionData\",\n    value: function () {\n      var _getTransactionData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var gasPrice, tx, label, revertMsg;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this._transaction;\n\n              case 3:\n                this.hash = _context2.sent;\n\n                if (this.hash.hash) {\n                  // When using websockets, the transaction hash is returned from this._transaction\n                  // Otherwise, the tx receipt is returned. This corrects in such cases\n                  this.hash = this.hash.hash;\n                }\n\n                this.setPending(); // set state to pending\n                // when you're on a local testnet, the transaction will probably already\n                // be mined by this point. but on other nets, you still have to wait for\n                // it to be mined.\n\n                if (!(!tx || !tx.blockHash)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                _context2.next = 9;\n                return this._keepWaitingForTx();\n\n              case 9:\n                tx = _context2.sent;\n\n              case 10:\n                gasPrice = tx.gasPrice;\n                this._timeStampMined = new Date();\n                this._blockNumberWhenMined = tx.blockNumber;\n                _context2.next = 15;\n                return this._waitForReceipt();\n\n              case 15:\n                this.receipt = _context2.sent;\n\n                if (!!this.receipt.gasUsed && !!gasPrice) {\n                  this._fees = ETH.wei(gasPrice).times(this.receipt.gasUsed);\n                } else {\n                  /*\n                    console.warn('Unable to calculate transaction fee. Gas usage or price is unavailable. Usage = ',\n                      receipt.gasUsed ? receipt.gasUsed.toString() : '<not set>',\n                      'Price = ', gasPrice ? gasPrice.toString() : '<not set>'\n                    );\n                  */\n                }\n\n                if (!(this.receipt.status == '0x1' || this.receipt.status == 1)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                this.setMined();\n                _context2.next = 25;\n                break;\n\n              case 21:\n                label = this.metadata.contract ? \"\".concat(this.metadata.contract, \".\").concat(this.metadata.method) : 'transaction';\n                revertMsg = \"\".concat(label, \" \").concat(this.hash, \" reverted\");\n                log(revertMsg + '\\n' + JSON.stringify(this.receipt, null, '  '));\n                throw new Error(revertMsg);\n\n              case 25:\n                _context2.next = 33;\n                break;\n\n              case 27:\n                _context2.prev = 27;\n                _context2.t0 = _context2[\"catch\"](0);\n                _context2.next = 31;\n                return this._nonceService.setCounts();\n\n              case 31:\n                this.setError(_context2.t0);\n                throw _context2.t0;\n\n              case 33:\n                return _context2.abrupt(\"return\", this);\n\n              case 34:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 27]]);\n      }));\n\n      function _getTransactionData() {\n        return _getTransactionData2.apply(this, arguments);\n      }\n\n      return _getTransactionData;\n    }()\n  }, {\n    key: \"_waitForReceipt\",\n    value: function _waitForReceipt() {\n      var _this3 = this;\n\n      var retries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n      var currentTry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var result = Promise.resolve(this._web3Service.getTransactionReceipt(this.hash));\n      if (retries < 1) return result;\n      return result.then(function (receipt) {\n        if (receipt) return receipt;\n        log(\"Receipt is null. Retrying \".concat(retries, \" more time(s)\"));\n        return promiseWait(currentTry * 1500).then(function () {\n          return _this3._waitForReceipt(retries - 1, currentTry + 1);\n        });\n      });\n    }\n  }, {\n    key: \"_keepWaitingForTx\",\n    value: function () {\n      var _keepWaitingForTx2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var tx, startTime, i, elapsed;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                startTime = new Date();\n                log(\"waiting for transaction \".concat(this.hash.substring(8), \"... to mine\"));\n                i = 0;\n\n              case 3:\n                if (!(i < 720)) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                _context3.next = 6;\n                return this._web3Service.getTransaction(this.hash);\n\n              case 6:\n                tx = _context3.sent;\n\n                if (!(tx || {}).blockHash) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                return _context3.abrupt(\"break\", 15);\n\n              case 9:\n                log('not mined yet');\n                _context3.next = 12;\n                return promiseWait(5000);\n\n              case 12:\n                i++;\n                _context3.next = 3;\n                break;\n\n              case 15:\n                if (!(tx && !tx.blockHash)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                throw new Error('This transaction is taking longer than it should. Check its status on etherscan or try again. Tx hash:', this.hash);\n\n              case 17:\n                elapsed = (new Date() - startTime) / 1000;\n                log(\"mined \".concat(this.hash.substring(8), \"... done in \").concat(elapsed, \"s\"));\n                return _context3.abrupt(\"return\", tx);\n\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _keepWaitingForTx() {\n        return _keepWaitingForTx2.apply(this, arguments);\n      }\n\n      return _keepWaitingForTx;\n    }()\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return TransactionObject;\n}(TransactionLifeCycle);\n\nexport { TransactionObject as default };\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(log, \"log\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/TransactionObject.js\");\n  reactHotLoader.register(TransactionObject, \"TransactionObject\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/TransactionObject.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/TransactionObject.js"],"names":["promiseWait","TransactionLifeCycle","debug","ETH","log","TransactionObject","transaction","transactionManager","businessObject","metadata","_transaction","_web3Service","get","_nonceService","_timeStampSubmitted","Date","_confirmedBlockCount","confirmedBlockCount","_timeStampMined","_fees","_dataPromise","_getTransactionData","then","_returnValue","_blockNumberWhenMined","blockNumber","setFinalized","count","mine","parseInt","newBlockNumber","receipt","waitForBlockNumber","getTransactionReceipt","hash","newReceipt","blockHash","Error","setPending","tx","_keepWaitingForTx","gasPrice","_waitForReceipt","gasUsed","wei","times","status","setMined","label","contract","method","revertMsg","JSON","stringify","setCounts","setError","retries","currentTry","result","Promise","resolve","startTime","substring","i","getTransaction","elapsed"],"mappings":"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","sourcesContent":["import { promiseWait } from '../utils';\nimport TransactionLifeCycle from '../eth/TransactionLifeCycle';\nimport debug from 'debug';\nimport { ETH } from './Currency';\n\nconst log = debug('dai:TransactionObject');\n\nexport default class TransactionObject extends TransactionLifeCycle {\n  constructor(\n    transaction,\n    transactionManager,\n    { businessObject, metadata } = {}\n  ) {\n    super(businessObject);\n    this._transaction = transaction;\n    this._web3Service = transactionManager.get('web3');\n    this._nonceService = transactionManager.get('nonce');\n    this._timeStampSubmitted = new Date();\n    this.metadata = metadata || {};\n    this._confirmedBlockCount = this._web3Service.confirmedBlockCount();\n  }\n\n  timeStampSubmitted() {\n    return this._timeStampSubmitted;\n  }\n\n  timeStamp() {\n    return this._timeStampMined;\n  }\n\n  fees() {\n    return this._fees;\n  }\n\n  mine() {\n    if (!this._dataPromise) this._dataPromise = this._getTransactionData();\n    return this._dataPromise.then(() => this._returnValue());\n  }\n\n  isFinalized() {\n    if (\n      this._blockNumberWhenMined + this._confirmedBlockCount <=\n      this._web3Service.blockNumber()\n    )\n      this.setFinalized();\n    return super.isFinalized();\n  }\n\n  async confirm(count = this._confirmedBlockCount) {\n    this._confirmedBlockCount = count;\n    await this.mine();\n    if (parseInt(count) <= 0) return;\n    const newBlockNumber = this.receipt.blockNumber + count;\n    await this._web3Service.waitForBlockNumber(newBlockNumber);\n    const newReceipt = await this._web3Service.getTransactionReceipt(this.hash);\n    if (newReceipt.blockHash !== this.receipt.blockHash) {\n      throw new Error('transaction block hash changed');\n    }\n    this.setFinalized();\n    return this._returnValue();\n  }\n\n  async _getTransactionData() {\n    try {\n      let gasPrice, tx;\n      this.hash = await this._transaction;\n      if (this.hash.hash) {\n        // When using websockets, the transaction hash is returned from this._transaction\n        // Otherwise, the tx receipt is returned. This corrects in such cases\n        this.hash = this.hash.hash;\n      }\n      this.setPending(); // set state to pending\n\n      // when you're on a local testnet, the transaction will probably already\n      // be mined by this point. but on other nets, you still have to wait for\n      // it to be mined.\n      if (!tx || !tx.blockHash) {\n        tx = await this._keepWaitingForTx();\n      }\n\n      gasPrice = tx.gasPrice;\n      this._timeStampMined = new Date();\n      this._blockNumberWhenMined = tx.blockNumber;\n      this.receipt = await this._waitForReceipt();\n      if (!!this.receipt.gasUsed && !!gasPrice) {\n        this._fees = ETH.wei(gasPrice).times(this.receipt.gasUsed);\n      } else {\n        /*\n          console.warn('Unable to calculate transaction fee. Gas usage or price is unavailable. Usage = ',\n            receipt.gasUsed ? receipt.gasUsed.toString() : '<not set>',\n            'Price = ', gasPrice ? gasPrice.toString() : '<not set>'\n          );\n        */\n      }\n      if (this.receipt.status == '0x1' || this.receipt.status == 1) {\n        this.setMined();\n      } else {\n        const label = this.metadata.contract\n          ? `${this.metadata.contract}.${this.metadata.method}`\n          : 'transaction';\n        const revertMsg = `${label} ${this.hash} reverted`;\n        log(revertMsg + '\\n' + JSON.stringify(this.receipt, null, '  '));\n        throw new Error(revertMsg);\n      }\n    } catch (err) {\n      await this._nonceService.setCounts();\n      this.setError(err);\n      throw err;\n    }\n    return this;\n  }\n\n  _waitForReceipt(retries = 15, currentTry = 1) {\n    const result = Promise.resolve(\n      this._web3Service.getTransactionReceipt(this.hash)\n    );\n\n    if (retries < 1) return result;\n    return result.then(receipt => {\n      if (receipt) return receipt;\n\n      log(`Receipt is null. Retrying ${retries} more time(s)`);\n      return promiseWait(currentTry * 1500).then(() =>\n        this._waitForReceipt(retries - 1, currentTry + 1)\n      );\n    });\n  }\n\n  async _keepWaitingForTx() {\n    let tx;\n    const startTime = new Date();\n    log(`waiting for transaction ${this.hash.substring(8)}... to mine`);\n    for (let i = 0; i < 720; i++) {\n      // 1 hour max\n      tx = await this._web3Service.getTransaction(this.hash);\n      if ((tx || {}).blockHash) break;\n      log('not mined yet');\n      await promiseWait(5000);\n    }\n\n    if (tx && !tx.blockHash) {\n      throw new Error(\n        'This transaction is taking longer than it should. Check its status on etherscan or try again. Tx hash:',\n        this.hash\n      );\n    }\n\n    const elapsed = (new Date() - startTime) / 1000;\n    log(`mined ${this.hash.substring(8)}... done in ${elapsed}s`);\n    return tx;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}