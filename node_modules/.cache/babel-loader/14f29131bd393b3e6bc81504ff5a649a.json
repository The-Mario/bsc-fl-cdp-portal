{"ast":null,"code":"import _objectSpread from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport vat from './vat';\nimport spot from './spot';\nimport proxyRegistry from './proxyRegistry';\nimport cdpManager from './cdpManager';\nimport jug from './jug';\nimport pot from './pot';\nimport cat from './cat';\nimport token from './token';\nimport end from './end';\nimport osm from './osm';\nimport getCdps from './getCdps';\nimport computed from './computed';\nimport reward from './reward';\nexport * from './_constants';\n\nvar _default = _objectSpread({}, vat, {}, spot, {}, proxyRegistry, {}, cdpManager, {}, jug, {}, pot, {}, cat, {}, computed, {}, token, {}, getCdps, {}, end, {}, osm, {}, reward);\n\nexport default _default;\n/*\n * Notes on structure:\n *\n * Base schemas, those which make a basic function call, such as vat.debt\n * should be stored in a file under the name of the contract which is to\n * be called from. In this case vat.js\n *\n * Naming of base observable schemas should follow the template of\n * camelCasing the contract name and function call. So following the\n * example of vat.debt, the resulting schema should be an exported\n * constant, vatDebt\n *\n * All observable keys should be located in the constants.js file.\n * For base observables, there could be 1 or more return values\n * using these constant names.\n *\n * For computed observables, the observable keys should match the name of\n * the exported constant. Using 'ilkPrices' as an example, the exported\n * constant will be ilkPrices, the corresponding constant key to match it\n * will be ILK_PRICES = 'ilkPrices'.\n *\n * In the majority of cases, computed observables should exist under\n * computed.js, especially if they are intending to compose calls to multiple\n * functions from multiple contracts.\n *\n * The exception to this is for instances where a computed observable has a\n * relationship with base observable(s) from a single contract such that a\n * untransformed and transformed value can be present within the api. An example\n * to better illustrate this is rawLiquidationRatio which returns a number value\n * and liquidationRatio which returns a currencyRatio object for that number\n * value. The baseObservable return value key should be prepended with \"raw\"\n * to strongly indicate we are getting a chain value. The computed key should\n * map to what the base observable key would be named should it not exist,\n * hence liquidationRatio. Both of the schemas for these should exist in the\n * file for the base observable, spot.js in this case.\n *\n */\n\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(_default, \"default\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/schemas/index.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/schemas/index.js"],"names":["vat","spot","proxyRegistry","cdpManager","jug","pot","cat","token","end","osm","getCdps","computed","reward"],"mappings":";;;;;;;;;;;AAAA,OAAOA,GAAP,MAAgB,OAAhB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AAEA,cAAc,cAAd;;iCAEKZ,G,MACAC,I,MACAC,a,MACAC,U,MACAC,G,MACAC,G,MACAC,G,MACAK,Q,MACAJ,K,MACAG,O,MACAF,G,MACAC,G,MACAG,M;;AAbL;AAgBA","sourcesContent":["import vat from './vat';\nimport spot from './spot';\nimport proxyRegistry from './proxyRegistry';\nimport cdpManager from './cdpManager';\nimport jug from './jug';\nimport pot from './pot';\nimport cat from './cat';\nimport token from './token';\nimport end from './end';\nimport osm from './osm';\nimport getCdps from './getCdps';\nimport computed from './computed';\nimport reward from './reward';\n\nexport * from './_constants';\nexport default {\n  ...vat,\n  ...spot,\n  ...proxyRegistry,\n  ...cdpManager,\n  ...jug,\n  ...pot,\n  ...cat,\n  ...computed,\n  ...token,\n  ...getCdps,\n  ...end,\n  ...osm,\n  ...reward\n};\n\n/*\n * Notes on structure:\n *\n * Base schemas, those which make a basic function call, such as vat.debt\n * should be stored in a file under the name of the contract which is to\n * be called from. In this case vat.js\n *\n * Naming of base observable schemas should follow the template of\n * camelCasing the contract name and function call. So following the\n * example of vat.debt, the resulting schema should be an exported\n * constant, vatDebt\n *\n * All observable keys should be located in the constants.js file.\n * For base observables, there could be 1 or more return values\n * using these constant names.\n *\n * For computed observables, the observable keys should match the name of\n * the exported constant. Using 'ilkPrices' as an example, the exported\n * constant will be ilkPrices, the corresponding constant key to match it\n * will be ILK_PRICES = 'ilkPrices'.\n *\n * In the majority of cases, computed observables should exist under\n * computed.js, especially if they are intending to compose calls to multiple\n * functions from multiple contracts.\n *\n * The exception to this is for instances where a computed observable has a\n * relationship with base observable(s) from a single contract such that a\n * untransformed and transformed value can be present within the api. An example\n * to better illustrate this is rawLiquidationRatio which returns a number value\n * and liquidationRatio which returns a currencyRatio object for that number\n * value. The baseObservable return value key should be prepended with \"raw\"\n * to strongly indicate we are getting a chain value. The computed key should\n * map to what the base observable key would be named should it not exist,\n * hence liquidationRatio. Both of the schemas for these should exist in the\n * file for the base observable, spot.js in this case.\n *\n */\n"]},"metadata":{},"sourceType":"module"}