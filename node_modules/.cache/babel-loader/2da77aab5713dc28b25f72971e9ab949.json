{"ast":null,"code":"import _toConsumableArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _applyDecoratedDescriptor from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\n\nvar _class;\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport tracksTransactions from '../utils/tracksTransactions';\nimport { PrivateService } from '@makerdao/services-core';\nimport { dappHub } from '../../contracts/abis';\nimport { Contract } from 'ethers';\nvar DSProxyService = (_class = /*#__PURE__*/function (_PrivateService) {\n  _inherits(DSProxyService, _PrivateService);\n\n  var _super = _createSuper(DSProxyService);\n\n  function DSProxyService() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'proxy';\n\n    _classCallCheck(this, DSProxyService);\n\n    return _super.call(this, name, ['web3']);\n  }\n\n  _createClass(DSProxyService, [{\n    key: \"authenticate\",\n    value: function () {\n      var _authenticate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.getProxyAddress();\n\n              case 2:\n                this._currentProxy = _context.sent;\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function authenticate() {\n        return _authenticate.apply(this, arguments);\n      }\n\n      return authenticate;\n    }() // workaround for a circular dependency:\n    // smartContract -> transactionManager -> proxy -> smartContract\n\n  }, {\n    key: \"setSmartContractService\",\n    value: function setSmartContractService(service) {\n      this._smartContractService = service;\n    }\n  }, {\n    key: \"_proxyRegistry\",\n    value: function _proxyRegistry() {\n      return this._smartContractService.getContract('PROXY_REGISTRY');\n    }\n  }, {\n    key: \"_resetDefaults\",\n    value: function _resetDefaults(newProxy) {\n      this._currentProxy = newProxy;\n      this._currentAddress = this.get('web3').currentAddress();\n    } // this needs to be async so it can fetch the proxy address just-in-time after\n    // an account switch. if we don't want this to be async, we have to make\n    // maker.useAccount async and set up a hook so that this service can get the\n    // new proxy address as soon as the switch happens\n\n  }, {\n    key: \"currentProxy\",\n    value: function () {\n      var _currentProxy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this._currentAddress === this.get('web3').currentAddress() ? this._currentProxy : this.getProxyAddress());\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function currentProxy() {\n        return _currentProxy.apply(this, arguments);\n      }\n\n      return currentProxy;\n    }()\n  }, {\n    key: \"ensureProxy\",\n    value: function () {\n      var _ensureProxy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref) {\n        var promise, proxy;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                promise = _ref.promise;\n                _context3.next = 3;\n                return this.currentProxy();\n\n              case 3:\n                proxy = _context3.sent;\n\n                if (!proxy) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", proxy);\n\n              case 6:\n                _context3.next = 8;\n                return this.build({\n                  promise: promise\n                });\n\n              case 8:\n                return _context3.abrupt(\"return\", this._currentProxy);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function ensureProxy(_x) {\n        return _ensureProxy.apply(this, arguments);\n      }\n\n      return ensureProxy;\n    }()\n  }, {\n    key: \"build\",\n    value: function () {\n      var _build = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref2) {\n        var promise, proxy, txo;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                promise = _ref2.promise;\n                _context4.next = 3;\n                return this.currentProxy();\n\n              case 3:\n                proxy = _context4.sent;\n\n                if (!proxy) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw new Error('This account already has a proxy deployed at ' + proxy);\n\n              case 6:\n                _context4.next = 8;\n                return this._proxyRegistry().build({\n                  promise: promise\n                });\n\n              case 8:\n                txo = _context4.sent;\n                this._currentProxy = txo.receipt.logs[0].address;\n                return _context4.abrupt(\"return\", txo);\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function build(_x2) {\n        return _build.apply(this, arguments);\n      }\n\n      return build;\n    }()\n  }, {\n    key: \"execute\",\n    value: function execute(contract, method, args, options, address) {\n      var _contract$interface$f;\n\n      if (!address && typeof this._currentProxy !== 'string') {\n        throw new Error('No proxy found for current account');\n      }\n\n      var proxyAddress = address ? address : this._currentProxy;\n      var proxyContract = this.getUnwrappedProxyContract(proxyAddress);\n\n      var data = (_contract$interface$f = contract.interface.functions)[method].apply(_contract$interface$f, _toConsumableArray(args)).data;\n\n      return proxyContract.execute(contract.address, data, options);\n    }\n  }, {\n    key: \"getProxyAddress\",\n    value: function () {\n      var _getProxyAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var providedAddress,\n            address,\n            proxyAddress,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                providedAddress = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : false;\n                address = providedAddress ? providedAddress : this.get('web3').currentAddress();\n                _context5.next = 4;\n                return this._proxyRegistry().proxies(address);\n\n              case 4:\n                proxyAddress = _context5.sent;\n\n                if (proxyAddress === '0x0000000000000000000000000000000000000000') {\n                  proxyAddress = null;\n                }\n\n                if (!providedAddress) this._resetDefaults(proxyAddress);\n                return _context5.abrupt(\"return\", proxyAddress);\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getProxyAddress() {\n        return _getProxyAddress.apply(this, arguments);\n      }\n\n      return getProxyAddress;\n    }()\n  }, {\n    key: \"getOwner\",\n    value: function () {\n      var _getOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(address) {\n        var contract;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                contract = this._getWrappedProxyContract(address);\n                return _context6.abrupt(\"return\", contract.owner());\n\n              case 2:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getOwner(_x3) {\n        return _getOwner.apply(this, arguments);\n      }\n\n      return getOwner;\n    }()\n  }, {\n    key: \"setOwner\",\n    value: function () {\n      var _setOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(newOwner) {\n        var proxyAddress,\n            contract,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                proxyAddress = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : this._currentProxy;\n                contract = this._getWrappedProxyContract(proxyAddress);\n                return _context7.abrupt(\"return\", contract.setOwner(newOwner));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function setOwner(_x4) {\n        return _setOwner.apply(this, arguments);\n      }\n\n      return setOwner;\n    }()\n  }, {\n    key: \"_getWrappedProxyContract\",\n    value: function _getWrappedProxyContract(address) {\n      return this._smartContractService.getContractByAddressAndAbi(address, dappHub.dsProxy);\n    }\n  }, {\n    key: \"getUnwrappedProxyContract\",\n    value: function getUnwrappedProxyContract(address) {\n      return new Contract(address, dappHub.dsProxy, this.get('web3').getEthersSigner());\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return DSProxyService;\n}(PrivateService), (_applyDecoratedDescriptor(_class.prototype, \"ensureProxy\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"ensureProxy\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"build\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"build\"), _class.prototype)), _class);\nexport { DSProxyService as default };\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(DSProxyService, \"DSProxyService\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/DSProxyService.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/DSProxyService.js"],"names":["tracksTransactions","PrivateService","dappHub","Contract","DSProxyService","name","getProxyAddress","_currentProxy","service","_smartContractService","getContract","newProxy","_currentAddress","get","currentAddress","promise","currentProxy","proxy","build","Error","_proxyRegistry","txo","receipt","logs","address","contract","method","args","options","proxyAddress","proxyContract","getUnwrappedProxyContract","data","interface","functions","execute","providedAddress","proxies","_resetDefaults","_getWrappedProxyContract","owner","newOwner","setOwner","getContractByAddressAndAbi","dsProxy","getEthersSigner"],"mappings":"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","sourcesContent":["import tracksTransactions from '../utils/tracksTransactions';\nimport { PrivateService } from '@makerdao/services-core';\nimport { dappHub } from '../../contracts/abis';\nimport { Contract } from 'ethers';\n\nexport default class DSProxyService extends PrivateService {\n  constructor(name = 'proxy') {\n    super(name, ['web3']);\n  }\n\n  async authenticate() {\n    this._currentProxy = await this.getProxyAddress();\n  }\n\n  // workaround for a circular dependency:\n  // smartContract -> transactionManager -> proxy -> smartContract\n  setSmartContractService(service) {\n    this._smartContractService = service;\n  }\n\n  _proxyRegistry() {\n    return this._smartContractService.getContract('PROXY_REGISTRY');\n  }\n\n  _resetDefaults(newProxy) {\n    this._currentProxy = newProxy;\n    this._currentAddress = this.get('web3').currentAddress();\n  }\n\n  // this needs to be async so it can fetch the proxy address just-in-time after\n  // an account switch. if we don't want this to be async, we have to make\n  // maker.useAccount async and set up a hook so that this service can get the\n  // new proxy address as soon as the switch happens\n  async currentProxy() {\n    return this._currentAddress === this.get('web3').currentAddress()\n      ? this._currentProxy\n      : this.getProxyAddress();\n  }\n\n  @tracksTransactions\n  async ensureProxy({ promise }) {\n    const proxy = await this.currentProxy();\n    if (proxy) return proxy;\n\n    await this.build({ promise });\n    return this._currentProxy;\n  }\n\n  @tracksTransactions\n  async build({ promise }) {\n    const proxy = await this.currentProxy();\n    if (proxy) {\n      throw new Error('This account already has a proxy deployed at ' + proxy);\n    }\n    const txo = await this._proxyRegistry().build({ promise });\n    this._currentProxy = txo.receipt.logs[0].address;\n    return txo;\n  }\n\n  execute(contract, method, args, options, address) {\n    if (!address && typeof this._currentProxy !== 'string') {\n      throw new Error('No proxy found for current account');\n    }\n    const proxyAddress = address ? address : this._currentProxy;\n    const proxyContract = this.getUnwrappedProxyContract(proxyAddress);\n    const data = contract.interface.functions[method](...args).data;\n    return proxyContract.execute(contract.address, data, options);\n  }\n\n  async getProxyAddress(providedAddress = false) {\n    const address = providedAddress\n      ? providedAddress\n      : this.get('web3').currentAddress();\n\n    let proxyAddress = await this._proxyRegistry().proxies(address);\n    if (proxyAddress === '0x0000000000000000000000000000000000000000') {\n      proxyAddress = null;\n    }\n\n    if (!providedAddress) this._resetDefaults(proxyAddress);\n    return proxyAddress;\n  }\n\n  async getOwner(address) {\n    const contract = this._getWrappedProxyContract(address);\n    return contract.owner();\n  }\n\n  async setOwner(newOwner, proxyAddress = this._currentProxy) {\n    const contract = this._getWrappedProxyContract(proxyAddress);\n    return contract.setOwner(newOwner);\n  }\n\n  _getWrappedProxyContract(address) {\n    return this._smartContractService.getContractByAddressAndAbi(\n      address,\n      dappHub.dsProxy\n    );\n  }\n\n  getUnwrappedProxyContract(address) {\n    return new Contract(\n      address,\n      dappHub.dsProxy,\n      this.get('web3').getEthersSigner()\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}