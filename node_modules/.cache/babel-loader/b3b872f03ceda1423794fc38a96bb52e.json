{"ast":null,"code":"import _toConsumableArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { PrivateService } from '@makerdao/services-core';\nimport contracts from '../../contracts/contracts';\nimport tokens from '../../contracts/tokens';\nimport networks, { contractAddressesInfo } from '../../contracts/networks';\nimport { Contract } from 'ethers';\nimport { wrapContract } from './smartContract/wrapContract';\nimport mapValues from 'lodash/mapValues';\nimport assert from 'assert';\n\nvar SmartContractService = /*#__PURE__*/function (_PrivateService) {\n  _inherits(SmartContractService, _PrivateService);\n\n  var _super = _createSuper(SmartContractService);\n\n  function SmartContractService() {\n    var _this;\n\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'smartContract';\n\n    _classCallCheck(this, SmartContractService);\n\n    _this = _super.call(this, name, ['web3', 'transactionManager']); // aliases\n\n    _this.getContractByName = _this.getContract;\n    _this.getContractAddressByName = _this.getContractAddress;\n    return _this;\n  }\n\n  _createClass(SmartContractService, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (settings.addContracts) {\n        this._addedContracts = Object.keys(settings.addContracts).reduce(function (acc, key) {\n          var def = settings.addContracts[key];\n          acc[key] = [_objectSpread({}, def, {\n            version: 1\n          })];\n          return acc;\n        }, {});\n      }\n\n      this._addressOverrides = settings.addressOverrides || {};\n      this.get('transactionManager').get('proxy').setSmartContractService(this);\n    }\n  }, {\n    key: \"getContractByAddressAndAbi\",\n    value: function getContractByAddressAndAbi(address, abi) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          name = _ref.name,\n          _ref$wrap = _ref.wrap,\n          wrap = _ref$wrap === void 0 ? true : _ref$wrap;\n\n      assert(address, \"Missing address for contract \\\"\".concat(name, \"\\\"\"));\n      if (!name) name = this.lookupContractName(address);\n      var web3Service = this.get('web3');\n      var signerOrProvider = web3Service.get('accounts').hasAccount() ? web3Service.getEthersSigner() : web3Service.getEthersSigner().provider;\n      var contract = new Contract(address, abi, signerOrProvider);\n      var txManager = wrap && this.get('transactionManager');\n      return wrapContract(contract, name, abi, txManager);\n    }\n  }, {\n    key: \"getContractAddress\",\n    value: function getContractAddress(name) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          version = _ref2.version;\n\n      var _this$_getContractInf = this._getContractInfo(name, version),\n          address = _this$_getContractInf.address;\n\n      return address;\n    }\n  }, {\n    key: \"getContractAddresses\",\n    value: function getContractAddresses() {\n      return mapValues(this._getAllContractInfo(), function (versions) {\n        return findLatestContractInfo(versions).address;\n      });\n    }\n  }, {\n    key: \"getContract\",\n    value: function getContract(name) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          version = _ref3.version,\n          _ref3$wrap = _ref3.wrap,\n          wrap = _ref3$wrap === void 0 ? true : _ref3$wrap;\n\n      var info = this._getContractInfo(name, version);\n\n      return this.getContractByAddressAndAbi(info.address, info.abi, {\n        name: name,\n        wrap: wrap\n      });\n    }\n  }, {\n    key: \"lookupContractName\",\n    value: function lookupContractName(address) {\n      address = address.toUpperCase();\n\n      var contracts = this._getAllContractInfo();\n\n      for (var _i = 0, _Object$keys = Object.keys(contracts); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n        var versions = contracts[name];\n\n        if (versions.find(function (info) {\n          return info.address && info.address.toUpperCase() === address;\n        })) {\n          return name;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"hasContract\",\n    value: function hasContract(name) {\n      return Object.keys(contracts).indexOf(name) > -1 || Object.keys(tokens).indexOf(name) > -1 || Object.keys(this._addedContracts || {}).indexOf(name) > -1;\n    } // generally we should be using the ethers contract interface. this is only\n    // for edge cases that the ethers contract interface doesn't support, like\n    // calling (but not sending) a non-constant function\n\n  }, {\n    key: \"getWeb3ContractByName\",\n    value: function getWeb3ContractByName(name) {\n      var _this$_getContractInf2 = this._getContractInfo(name),\n          abi = _this$_getContractInf2.abi,\n          address = _this$_getContractInf2.address;\n\n      return this.get('web3').web3Contract(abi, address);\n    }\n  }, {\n    key: \"_getContractInfo\",\n    value: function _getContractInfo(name, version) {\n      assert(this.hasContract(name), \"No contract found for \\\"\".concat(name, \"\\\"\"));\n\n      var contracts = this._getAllContractInfo();\n\n      var contractInfo = findContractInfoForVersion(contracts[name], version);\n      assert(contractInfo, \"Cannot find contract \".concat(name, \", version \").concat(version));\n      assert(contractInfo.address, \"Contract \".concat(name, \" has no address\"));\n      return contractInfo;\n    }\n  }, {\n    key: \"_getAllContractInfo\",\n    value: function _getAllContractInfo() {\n      var _this2 = this;\n\n      var _this$get = this.get('web3'),\n          networkName = _this$get.networkName;\n\n      var mapping = networks.find(function (m) {\n        return m.name === networkName;\n      });\n      assert(mapping, \"Network \\\"\".concat(networkName, \"\\\" not found in mapping.\"));\n      if (!mapping.contracts) mapping.contracts = contractAddressesInfo(this._addressOverrides);\n      if (!this._contractInfoCache) this._contractInfoCache = {};\n\n      if (!this._contractInfoCache[networkName]) {\n        var allContractInfo = this._addedContracts ? _objectSpread({}, mapping.contracts, {}, this._addedContracts) : mapping.contracts;\n        this._contractInfoCache[networkName] = mapValues(allContractInfo, function (versions, name) {\n          var latest = findLatestContractInfo(versions);\n          var address = getSingleAddress(_this2._addressOverrides[name], networkName) || getSingleAddress(latest.address, networkName);\n          return address !== latest.address ? versions.map(function (v) {\n            return v === latest ? _objectSpread({}, latest, {\n              address: address\n            }) : v;\n          }) : versions;\n        });\n      }\n\n      return this._contractInfoCache[networkName];\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return SmartContractService;\n}(PrivateService);\n\nexport { SmartContractService as default };\n\nfunction findContractInfoForVersion(versions, version) {\n  if (!version) version = Math.max.apply(Math, _toConsumableArray(versions.map(function (info) {\n    return info.version;\n  })));\n  return versions.find(function (info) {\n    return info.version === version;\n  });\n}\n\nfunction findLatestContractInfo(versions) {\n  return findContractInfoForVersion(versions);\n}\n\nfunction getSingleAddress(addressGroup, networkName) {\n  if (!addressGroup) return;\n  if (typeof addressGroup === 'string') return addressGroup;\n  if (addressGroup[networkName]) return addressGroup[networkName]; // some configuration uses 'testnet' instead of 'test' as the network name\n\n  if (networkName.startsWith('test') && addressGroup.testnet) return addressGroup.testnet; // return nothing if addressGroup has no address defined for this network\n}\n\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(SmartContractService, \"SmartContractService\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/SmartContractService.js\");\n  reactHotLoader.register(findContractInfoForVersion, \"findContractInfoForVersion\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/SmartContractService.js\");\n  reactHotLoader.register(findLatestContractInfo, \"findLatestContractInfo\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/SmartContractService.js\");\n  reactHotLoader.register(getSingleAddress, \"getSingleAddress\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/SmartContractService.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/SmartContractService.js"],"names":["PrivateService","contracts","tokens","networks","contractAddressesInfo","Contract","wrapContract","mapValues","assert","SmartContractService","name","getContractByName","getContract","getContractAddressByName","getContractAddress","settings","addContracts","_addedContracts","Object","keys","reduce","acc","key","def","version","_addressOverrides","addressOverrides","get","setSmartContractService","address","abi","wrap","lookupContractName","web3Service","signerOrProvider","hasAccount","getEthersSigner","provider","contract","txManager","_getContractInfo","_getAllContractInfo","versions","findLatestContractInfo","info","getContractByAddressAndAbi","toUpperCase","find","indexOf","web3Contract","hasContract","contractInfo","findContractInfoForVersion","networkName","mapping","m","_contractInfoCache","allContractInfo","latest","getSingleAddress","map","v","Math","max","addressGroup","startsWith","testnet"],"mappings":"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","sourcesContent":["import { PrivateService } from '@makerdao/services-core';\nimport contracts from '../../contracts/contracts';\nimport tokens from '../../contracts/tokens';\nimport networks, { contractAddressesInfo } from '../../contracts/networks';\nimport { Contract } from 'ethers';\nimport { wrapContract } from './smartContract/wrapContract';\nimport mapValues from 'lodash/mapValues';\nimport assert from 'assert';\n\nexport default class SmartContractService extends PrivateService {\n  constructor(name = 'smartContract') {\n    super(name, ['web3', 'transactionManager']);\n\n    // aliases\n    this.getContractByName = this.getContract;\n    this.getContractAddressByName = this.getContractAddress;\n  }\n\n  initialize(settings = {}) {\n    if (settings.addContracts) {\n      this._addedContracts = Object.keys(settings.addContracts).reduce(\n        (acc, key) => {\n          const def = settings.addContracts[key];\n          acc[key] = [{ ...def, version: 1 }];\n          return acc;\n        },\n        {}\n      );\n    }\n\n    this._addressOverrides = settings.addressOverrides || {};\n\n    this.get('transactionManager')\n      .get('proxy')\n      .setSmartContractService(this);\n  }\n\n  getContractByAddressAndAbi(address, abi, { name, wrap = true } = {}) {\n    assert(address, `Missing address for contract \"${name}\"`);\n    if (!name) name = this.lookupContractName(address);\n\n    const web3Service = this.get('web3');\n    const signerOrProvider = web3Service.get('accounts').hasAccount()\n      ? web3Service.getEthersSigner()\n      : web3Service.getEthersSigner().provider;\n\n    const contract = new Contract(address, abi, signerOrProvider);\n    const txManager = wrap && this.get('transactionManager');\n    return wrapContract(contract, name, abi, txManager);\n  }\n\n  getContractAddress(name, { version } = {}) {\n    const { address } = this._getContractInfo(name, version);\n    return address;\n  }\n\n  getContractAddresses() {\n    return mapValues(\n      this._getAllContractInfo(),\n      versions => findLatestContractInfo(versions).address\n    );\n  }\n\n  getContract(name, { version, wrap = true } = {}) {\n    const info = this._getContractInfo(name, version);\n    return this.getContractByAddressAndAbi(info.address, info.abi, {\n      name,\n      wrap\n    });\n  }\n\n  lookupContractName(address) {\n    address = address.toUpperCase();\n    const contracts = this._getAllContractInfo();\n    for (let name of Object.keys(contracts)) {\n      const versions = contracts[name];\n      if (\n        versions.find(\n          info => info.address && info.address.toUpperCase() === address\n        )\n      ) {\n        return name;\n      }\n    }\n\n    return null;\n  }\n\n  hasContract(name) {\n    return (\n      Object.keys(contracts).indexOf(name) > -1 ||\n      Object.keys(tokens).indexOf(name) > -1 ||\n      Object.keys(this._addedContracts || {}).indexOf(name) > -1\n    );\n  }\n\n  // generally we should be using the ethers contract interface. this is only\n  // for edge cases that the ethers contract interface doesn't support, like\n  // calling (but not sending) a non-constant function\n  getWeb3ContractByName(name) {\n    const { abi, address } = this._getContractInfo(name);\n    return this.get('web3').web3Contract(abi, address);\n  }\n\n  _getContractInfo(name, version) {\n    assert(this.hasContract(name), `No contract found for \"${name}\"`);\n    const contracts = this._getAllContractInfo();\n    const contractInfo = findContractInfoForVersion(contracts[name], version);\n    assert(contractInfo, `Cannot find contract ${name}, version ${version}`);\n    assert(contractInfo.address, `Contract ${name} has no address`);\n    return contractInfo;\n  }\n\n  _getAllContractInfo() {\n    let { networkName } = this.get('web3');\n    const mapping = networks.find(m => m.name === networkName);\n    assert(mapping, `Network \"${networkName}\" not found in mapping.`);\n\n    if (!mapping.contracts)\n      mapping.contracts = contractAddressesInfo(this._addressOverrides);\n\n    if (!this._contractInfoCache) this._contractInfoCache = {};\n    if (!this._contractInfoCache[networkName]) {\n      const allContractInfo = this._addedContracts\n        ? {\n            ...mapping.contracts,\n            ...this._addedContracts\n          }\n        : mapping.contracts;\n\n      this._contractInfoCache[networkName] = mapValues(\n        allContractInfo,\n        (versions, name) => {\n          const latest = findLatestContractInfo(versions);\n          const address =\n            getSingleAddress(this._addressOverrides[name], networkName) ||\n            getSingleAddress(latest.address, networkName);\n          return address !== latest.address\n            ? versions.map(v => (v === latest ? { ...latest, address } : v))\n            : versions;\n        }\n      );\n    }\n\n    return this._contractInfoCache[networkName];\n  }\n}\n\nfunction findContractInfoForVersion(versions, version) {\n  if (!version) version = Math.max(...versions.map(info => info.version));\n  return versions.find(info => info.version === version);\n}\n\nfunction findLatestContractInfo(versions) {\n  return findContractInfoForVersion(versions);\n}\n\nfunction getSingleAddress(addressGroup, networkName) {\n  if (!addressGroup) return;\n\n  if (typeof addressGroup === 'string') return addressGroup;\n\n  if (addressGroup[networkName]) return addressGroup[networkName];\n\n  // some configuration uses 'testnet' instead of 'test' as the network name\n  if (networkName.startsWith('test') && addressGroup.testnet)\n    return addressGroup.testnet;\n\n  // return nothing if addressGroup has no address defined for this network\n}\n"]},"metadata":{},"sourceType":"module"}