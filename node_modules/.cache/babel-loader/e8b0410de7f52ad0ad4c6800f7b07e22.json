{"ast":null,"code":"import _toArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { PublicService } from '@makerdao/services-core';\nimport { createWatcher as _createWatcher } from '@makerdao/multicall';\nimport debug from 'debug';\nimport { Observable, ReplaySubject, combineLatest, from, throwError, timer } from 'rxjs';\nimport { map, flatMap, debounceTime, take, catchError, filter, takeUntil, throwIfEmpty, tap } from 'rxjs/operators';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\nimport find from 'lodash/find';\nvar log = debug('dai:MulticallService');\nvar log2 = debug('dai:MulticallService:observables');\n\nvar throwIfErrorInValues = function throwIfErrorInValues(values) {\n  return values.map(function (v) {\n    if (v instanceof Error) throw v;\n  });\n}; // prettier-ignore\n\n\nvar checkForErrors = function checkForErrors(values) {\n  return find(values, function (v) {\n    return v instanceof Error;\n  }) === undefined;\n};\n\nvar catchNestedErrors = function catchNestedErrors(key) {\n  return function (f) {\n    return catchError(function (err) {\n      log2(\"Caught nested error in \".concat(key, \": \").concat(err));\n      return from([new Error(err)]);\n    })(f);\n  };\n};\n\nvar MulticallService = /*#__PURE__*/function (_PublicService) {\n  _inherits(MulticallService, _PublicService);\n\n  var _super = _createSuper(MulticallService);\n\n  function MulticallService() {\n    var _this;\n\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'multicall';\n\n    _classCallCheck(this, MulticallService);\n\n    _this = _super.call(this, name, ['web3', 'smartContract']);\n    _this._schemas = [];\n    _this._schemaByObservableKey = {};\n    _this._schemaInstances = {};\n    _this._subjects = {};\n    _this._observables = {};\n    _this._watcherUpdates = null;\n    _this._schemaSubscribers = {};\n    _this._totalSchemaSubscribers = 0;\n    _this._totalActiveSchemas = 0;\n    _this._multicallResultCache = {};\n    _this._addresses = {};\n    _this._removeSchemaTimers = {};\n    return _this;\n  }\n\n  _createClass(MulticallService, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._addresses = settings.addresses || this.get('smartContract').getContractAddresses();\n      this._removeSchemaDelay = settings.removeSchemaDelay || 1000;\n      this._debounceTime = settings.debounceTime || 1;\n      this._latestDebounceTime = settings.latestDebounceTime || 1;\n      this._latestTimeout = settings.latestTimeout || 10000;\n    }\n  }, {\n    key: \"authenticate\",\n    value: function authenticate() {\n      this._connectedAddress = this.get('web3').currentAddress();\n    }\n  }, {\n    key: \"createWatcher\",\n    value: function createWatcher() {\n      var _this2 = this;\n\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$useWeb3Provider = _ref.useWeb3Provider,\n          useWeb3Provider = _ref$useWeb3Provider === void 0 ? false : _ref$useWeb3Provider,\n          _ref$interval = _ref.interval,\n          interval = _ref$interval === void 0 ? 'block' : _ref$interval,\n          rpcUrl = _ref.rpcUrl,\n          config = _objectWithoutProperties(_ref, [\"useWeb3Provider\", \"interval\", \"rpcUrl\"]);\n\n      var web3 = this.get('web3');\n      config = _objectSpread({\n        multicallAddress: this.get('smartContract').getContractAddress('MULTICALL')\n      }, config);\n      var onNewBlockPolling = interval === 'block';\n      if (onNewBlockPolling) interval = 60000; // 1 min polling fallback safeguard\n\n      if (useWeb3Provider) config.web3 = web3._web3;else if (!rpcUrl) {\n        if (!web3.rpcUrl) new Error('Unable to get rpcUrl for multicall');\n        rpcUrl = web3.rpcUrl;\n      }\n      this._watcher = _createWatcher([], _objectSpread({}, config, {\n        interval: interval,\n        rpcUrl: rpcUrl\n      }));\n\n      if (onNewBlockPolling) {\n        log(\"Watcher created with poll on new block mode using \".concat(rpcUrl ? \"rpcUrl: \".concat(rpcUrl) : 'web3 provider')); // prettier-ignore\n\n        web3.onNewBlock(function (blockNumber) {\n          log(\"Polling after new block detected (\".concat(blockNumber, \")\"));\n\n          _this2._watcher.poll();\n        });\n      } else {\n        log(\"Watcher created with \".concat(interval, \"ms polling interval using \").concat(useWeb3Provider ? 'web3 provider' : \"rpcUrl: \".concat(rpcUrl)));\n      }\n\n      this._watcher.onPoll(function (_ref2) {\n        var id = _ref2.id,\n            block = _ref2.latestBlockNumber;\n        return log(\"Sending network request #\".concat(id).concat(block ? \" (latest block: \".concat(block, \")\") : ''));\n      });\n\n      this._watcher.onNewBlock(function (block) {\n        return log(\"Latest block: \".concat(block));\n      });\n\n      this._watcher.onError(function (err) {\n        return console.error('Multicall error:', err);\n      });\n\n      return this._watcher;\n    }\n  }, {\n    key: \"tap\",\n    value: function tap(cb) {\n      log('Watcher tapped');\n      return this._watcher.tap(cb);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      log('Watcher started');\n      return this._watcher.start();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._flushPendingSchemaRemovals();\n\n      log('Watcher stopped');\n      return this._watcher.stop();\n    }\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      this.stop();\n      this.start();\n    }\n  }, {\n    key: \"schemaByObservableKey\",\n    value: function schemaByObservableKey(key) {\n      if (!key) throw new Error('Invalid observable key');\n      if (!this._schemaByObservableKey[key]) throw new Error(\"No registered schema definition found with observable key: \".concat(key));\n      return this._schemaByObservableKey[key];\n    }\n  }, {\n    key: \"registerSchemas\",\n    // Register schema definitions\n    value: function registerSchemas(schemas) {\n      var _this3 = this;\n\n      if (typeof schemas !== 'object') throw new Error('Schemas must be object or array'); // If schemas is key/val object use key as schema key and convert to array object\n\n      if (!Array.isArray(schemas)) schemas = Object.keys(schemas).map(function (key) {\n        return _objectSpread({\n          key: key\n        }, schemas[key]);\n      }); // prettier-ignore\n      // Clone if array\n      else schemas = schemas.map(function (item) {\n          return _objectSpread({}, item);\n        });\n      schemas.forEach(function (schema) {\n        if (!schema.key) throw new Error('Schema definitions must have a unique key'); // Automatically use schema key as return key if no return keys specified\n\n        if (!schema.return && !schema.returns) schema.returns = [schema.key];\n        if (schema.return && schema.returns) throw new Error('Ambiguous return definitions in schema: found both return and returns property'); // prettier-ignore\n\n        if (schema.return) schema.returns = [schema.return];\n        if (!Array.isArray(schema.returns)) throw new Error('Schema must contain return/returns property'); // Use return keys to create observable key => schema mapping\n        // and normalize as array of [key, transform] arrays\n\n        schema.returns = schema.returns.map(function (ret) {\n          if (!Array.isArray(ret)) ret = [ret];\n          if (_this3._schemaByObservableKey[ret[0]] !== undefined) throw new Error(\"Observable with key \".concat(ret[0], \" already registered\"));\n          _this3._schemaByObservableKey[ret[0]] = schema;\n          if (ret.length > 2) throw new Error('Returns array format should be [key, transform]');\n          return ret;\n        });\n      });\n      this._schemas = [].concat(_toConsumableArray(this._schemas), _toConsumableArray(schemas));\n      log2(\"Registered \".concat(schemas.length, \" schemas\"));\n    }\n  }, {\n    key: \"latest\",\n    value: function latest(key) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var obsPath = \"\".concat(key).concat(args.length > 0 ? '.' : '').concat(args.join('.'));\n      return this._watch.apply(this, [{\n        depth: 0,\n        throwIfError: true\n      }, key].concat(args)).pipe(catchError(function (err) {\n        throw new Error(err);\n      }), takeUntil(timer(this._latestTimeout)), throwIfEmpty(function () {\n        return new Error(\"Timed out waiting for latest value of: \".concat(obsPath));\n      }), debounceTime(this._latestDebounceTime), take(1)).toPromise();\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(key) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return this._watch.apply(this, [{\n        depth: 0\n      }, key].concat(args));\n    }\n  }, {\n    key: \"_watch\",\n    value: function _watch(_ref3, key) {\n      var _schemaDefinition$val,\n          _this4 = this;\n\n      var depth = _ref3.depth,\n          _ref3$throwIfError = _ref3.throwIfError,\n          throwIfError = _ref3$throwIfError === void 0 ? false : _ref3$throwIfError;\n      // Find schema definition associated with this observable key\n      var schemaDefinition = this.schemaByObservableKey(key);\n      var expectedArgs = schemaDefinition.generate.length;\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      if (args.length < expectedArgs) return throwError(\"Observable \".concat(key, \" expects at least \").concat(expectedArgs, \" argument(s)\"));\n      var obsPath = \"\".concat(key).concat(args.length > 0 ? '.' : '').concat(args.join('.')); // Validate arguments using schema args validator\n\n      if (schemaDefinition === null || schemaDefinition === void 0 ? void 0 : (_schemaDefinition$val = schemaDefinition.validate) === null || _schemaDefinition$val === void 0 ? void 0 : _schemaDefinition$val.args) {\n        var _schemaDefinition$val2;\n\n        var validate = (_schemaDefinition$val2 = schemaDefinition.validate).args.apply(_schemaDefinition$val2, args);\n\n        if (validate) {\n          log2(\"Input validation failed for observable: \".concat(obsPath, \" (depth: \").concat(depth, \")\"));\n          return throwError(validate);\n        }\n      } // Create or get existing schema instance for this instance path (schema definition + args)\n\n\n      var schemaInstance = this._createSchemaInstance.apply(this, [schemaDefinition].concat(args));\n\n      var computed = schemaInstance.computed;\n      log2(\"watch() called for \".concat(computed ? 'computed ' : 'base ', \"observable: \").concat(obsPath, \" (depth: \").concat(depth, \")\")); // prettier-ignore\n      // Return existing observable if one already exists for this observable path (key + args)\n\n      var existing = get(this._observables, obsPath);\n\n      if (existing) {\n        if (computed) {\n          log2(\"Returning existing computed observable: \".concat(obsPath, \" (depth: \").concat(depth, \")\")); // Only debounce if call to watch() is not nested\n\n          if (depth === 0) existing = existing.pipe(debounceTime(this._debounceTime));\n          if (throwIfError) existing = existing.pipe(tap(throwIfErrorInValues));\n          return existing.pipe( // Don't pass values to computed() if any of them are errors\n          filter(checkForErrors), // Pass values to computed() on the computed observable\n          map(function (result) {\n            return computed.apply(void 0, _toConsumableArray(result));\n          }));\n        }\n\n        log2(\"Returning existing base observable: \".concat(obsPath));\n        return existing;\n      } // Handle computed observable\n\n\n      if (computed) {\n        // Handle dynamically generated dependencies\n        var dependencies = typeof schemaInstance.dependencies === 'function' ? schemaInstance.dependencies({\n          watch: this.watch.bind(this),\n          get: this.get.bind(this)\n        }) : schemaInstance.dependencies;\n\n        var recurseDependencyTree = function recurseDependencyTree(trie_) {\n          var key = trie_[0];\n          var trie = trie_.slice(1); // If the dependency key provided is a function, promise or array of\n          // values then this dependency is providing its own custom value\n          // rather than specifying an existing observable key\n\n          if (key instanceof Promise || Array.isArray(key)) return from(key);\n          if (typeof key === 'function') return from(key());\n          var indexesAtLeafNodes = trie.map(function (node) {\n            return !Array.isArray(node);\n          });\n          var allLeafNodes = indexesAtLeafNodes.every(function (node) {\n            return node === true;\n          });\n\n          if (Array.isArray(trie) && trie.length === 0) {\n            // When trie is an empty array, indicates that we only need to return\n            // watch on the key\n            return _this4._watch({\n              depth: depth + 1\n            }, key);\n          } else if (allLeafNodes) {\n            // If the trie is an array it indicates that the observable is\n            // expecting arguments. These can be normal values or other\n            // observables. Where an index in the trie is an array, it is\n            // assumed that it is syntax for an observable argument. In the case\n            // where all indexes in the trie array are normal values, we use the\n            // spread operator to pass them to the returned watch fn\n            return _this4._watch.apply(_this4, [{\n              depth: depth + 1\n            }, key].concat(_toConsumableArray(trie)));\n          } else {\n            // When a trie array has nested observables, recursively call this fn\n            // on indexes which have an array.\n            return combineLatest(trie.map(function (node, idx) {\n              return indexesAtLeafNodes[idx] ? [node] : recurseDependencyTree(node);\n            })).pipe(flatMap(function (result) {\n              return _this4._watch.apply(_this4, [{\n                depth: depth + 1\n              }, key].concat(_toConsumableArray(result))).pipe(catchNestedErrors(key));\n            }));\n          }\n        };\n\n        var dependencySubs = dependencies.map(recurseDependencyTree);\n\n        var _observable = combineLatest(dependencySubs);\n\n        log2(\"Created new computed observable: \".concat(obsPath, \" (depth: \").concat(depth, \")\"));\n        set(this._observables, obsPath, _observable); // Only debounce if call to watch() is not nested\n\n        if (depth === 0) _observable = _observable.pipe(debounceTime(this._debounceTime));\n        if (throwIfError) _observable = _observable.pipe(tap(throwIfErrorInValues));\n        return _observable.pipe( // Don't pass values to computed() if any of them are errors\n        filter(checkForErrors), // Pass values to computed() on the computed observable\n        map(function (result) {\n          return computed.apply(void 0, _toConsumableArray(result));\n        }));\n      } // This is a base observable\n\n\n      var id = schemaInstance.id,\n          path = schemaInstance.path;\n      if (this._schemaSubscribers[path] === undefined) this._schemaSubscribers[path] = 0;\n      var subject = new ReplaySubject(1);\n      set(this._subjects, obsPath, subject); // Handle initial value if cached result from multicall exists\n\n      if (this._multicallResultCache[obsPath] !== undefined) this._handleResult(subject, obsPath, this._multicallResultCache[obsPath]); // Create base observable\n\n      var observable = Observable.create(function (observer) {\n        _this4._totalSchemaSubscribers++;\n        log2(\"Observer subscribed to \".concat(id, \" (\").concat(_this4._schemaSubscribers[path] + 1, \" subscribers)\")); // If first subscriber to this schema add it to multicall\n\n        if (++_this4._schemaSubscribers[path] === 1) _this4._addSchemaToMulticall(schemaInstance); // Subscribe to watcher updates and emit them to subjects\n\n        if (!_this4._watcherUpdates) _this4._subscribeToWatcherUpdates(); // Subscribe this observer to the subject for this base observable\n\n        var sub = subject.subscribe(observer); // Return the function to call when this observer unsubscribes\n\n        return function () {\n          _this4._totalSchemaSubscribers--; // If last unsubscriber from this schema remove it from multicall\n\n          if (--_this4._schemaSubscribers[path] === 0) _this4._removeSchemaFromMulticall(schemaInstance.id); // Unsubscribe this observer from the subject for this base observable\n\n          sub.unsubscribe();\n          log2(\"Observer unsubscribed from \".concat(id, \" (\").concat(_this4._schemaSubscribers[path], \" subscribers)\")); // prettier-ignore\n        };\n      });\n      log2(\"Created new base observable: \".concat(obsPath));\n      set(this._observables, obsPath, observable);\n      return observable;\n    }\n  }, {\n    key: \"_createSchemaInstance\",\n    value: function _createSchemaInstance(schemaDefinition) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n\n      var path = args.join('.');\n      var instancePath = \"\".concat(schemaDefinition.key).concat(path ? '.' : '').concat(path); // Return existing schema if found for this instance path (schema key + args)\n\n      if (this._schemaInstances[instancePath]) return this._schemaInstances[instancePath]; // Generate schema instance\n\n      var schemaInstance = schemaDefinition.generate.apply(schemaDefinition, args);\n      this._schemaInstances[instancePath] = schemaInstance;\n      schemaInstance.args = [].concat(args); // Auto generate some fields if this is a base schema\n\n      if (!schemaInstance.computed) {\n        var returns = schemaInstance.returns,\n            _schemaInstance$trans = schemaInstance.transforms,\n            transforms = _schemaInstance$trans === void 0 ? {} : _schemaInstance$trans;\n        schemaInstance.path = instancePath; // Auto generate return keys for schema instance if not provided by generate()\n\n        if (!returns) {\n          schemaInstance.returns = schemaDefinition.returns.map(function (ret) {\n            var key = ret[0];\n            var fullPath = \"\".concat(key).concat(path ? '.' : '').concat(path);\n            return transforms[key] ? [fullPath, transforms[key]] // Use transform mapping in generated schema instance if available\n            : ret.length == 2 ? [fullPath, ret[1]] : [fullPath];\n          });\n        } // Resolve target contract address if contract string is provided\n\n\n        var target = schemaInstance.target,\n            contract = schemaInstance.contract;\n        if (!target && !contract) throw new Error('Schema must specify target address or contract');\n        if (!target && !this._addresses[contract]) throw new Error(\"Can't find contract address for \".concat(contract)); // prettier-ignore\n\n        schemaInstance.target = target || this._addresses[contract];\n      }\n\n      return schemaInstance;\n    }\n  }, {\n    key: \"_addSchemaToMulticall\",\n    value: function _addSchemaToMulticall(schemaInstance) {\n      var _process;\n\n      var id = schemaInstance.id,\n          target = schemaInstance.target,\n          call = schemaInstance.call,\n          returns = schemaInstance.returns; // If schema already added but pending removal then cancel pending removal\n\n      if (this._removeSchemaTimers[id]) {\n        log2(\"Cancelled pending schema removal: \".concat(id));\n        clearTimeout(this._removeSchemaTimers[id]);\n        delete this._removeSchemaTimers[id];\n        return;\n      }\n\n      this._totalActiveSchemas++;\n\n      this._watcher.tap(function (calls) {\n        return [].concat(_toConsumableArray(calls), [{\n          id: id,\n          target: target,\n          call: call,\n          returns: returns\n        }]);\n      });\n\n      log2(\"Schema added to multicall: \".concat(id));\n      if ((_process = process) === null || _process === void 0 ? void 0 : _process.browser) log2('Active schemas (' + this._totalActiveSchemas + ' total):', this.activeSchemaIds);else log2(\"Active schemas (\".concat(this._totalActiveSchemas, \" total): \").concat(this.activeSchemaIds.join(','))); // prettier-ignore\n    }\n  }, {\n    key: \"_removeSchemaImmediately\",\n    value: function _removeSchemaImmediately(id) {\n      if (this._removeSchemaTimers[id] !== undefined) delete this._removeSchemaTimers[id];\n      log2(\"Schema removed from multicall: \".concat(id));\n\n      this._watcher.tap(function (schemas) {\n        return schemas.filter(function (_ref4) {\n          var id_ = _ref4.id;\n          return id_ !== id;\n        });\n      }); // If there are no active schemas unsubscribe from watcher updates\n\n\n      if (--this._totalActiveSchemas === 0) {\n        log2('No remaining active schemas');\n        log2('Unsubscribed from watcher updates');\n\n        this._watcherUpdates.unsub();\n\n        this._watcherUpdates = null;\n      } else {\n        var _process2;\n\n        if ((_process2 = process) === null || _process2 === void 0 ? void 0 : _process2.browser) log2('Active schemas (' + this._totalActiveSchemas + ' total):', this.activeSchemaIds);else log2(\"Active schemas (\".concat(this._totalActiveSchemas, \" remaining): \").concat(this.activeSchemaIds.join(','))); // prettier-ignore\n      }\n    }\n  }, {\n    key: \"_removeSchemaFromMulticall\",\n    value: function _removeSchemaFromMulticall(id) {\n      var _this5 = this;\n\n      this._removeSchemaTimers[id] = setTimeout(function () {\n        return _this5._removeSchemaImmediately(id);\n      }, this._removeSchemaDelay);\n    }\n  }, {\n    key: \"_flushPendingSchemaRemovals\",\n    value: function _flushPendingSchemaRemovals() {\n      var schemaTimers = Object.keys(this._removeSchemaTimers);\n      if (schemaTimers.length === 0) return;\n      log2(\"Flushing \".concat(schemaTimers.length, \" pending schema removals\"));\n\n      for (var _i = 0, _schemaTimers = schemaTimers; _i < _schemaTimers.length; _i++) {\n        var id = _schemaTimers[_i];\n        log2(\"Forcing schema removal: \".concat(id));\n        clearTimeout(this._removeSchemaTimers[id]);\n\n        this._removeSchemaImmediately(id);\n      }\n    }\n  }, {\n    key: \"_handleResult\",\n    value: function _handleResult(subject, obsPath, value) {\n      var err = this._validateResult(subject, obsPath, value); // Trigger error on observable or emit result value to observable\n\n\n      if (err) subject.error(err);else subject.next(value);\n    }\n  }, {\n    key: \"_validateResult\",\n    value: function _validateResult(subject, obsPath, value) {\n      var _schemaDefinition$val3;\n\n      var _obsPath$split = obsPath.split('.'),\n          _obsPath$split2 = _toArray(_obsPath$split),\n          observableKey = _obsPath$split2[0],\n          args = _obsPath$split2.slice(1);\n\n      var schemaDefinition = this._schemaByObservableKey[observableKey];\n      var instancePath = \"\".concat(schemaDefinition.key).concat(args.length > 0 ? '.' : '').concat(args.join('.'));\n      var schemaInstance = this._schemaInstances[instancePath]; // Pass validation if no validator found for this schema definition\n\n      if (!((_schemaDefinition$val3 = schemaDefinition.validate) === null || _schemaDefinition$val3 === void 0 ? void 0 : _schemaDefinition$val3.hasOwnProperty(observableKey))) return;\n\n      try {\n        // Call validation func on schema definition for result value and pass schema instance args\n        // as 2nd param and also this context\n        var validate = schemaDefinition.validate[observableKey].call({\n          args: schemaInstance.args\n        }, value, schemaInstance.args);\n        if (validate) throw new Error(validate);\n        return; // Pass validation\n      } catch (err) {\n        log2('Validation error for ' + obsPath + ' result:', value);\n        return err; // Fail validation\n      }\n    }\n  }, {\n    key: \"_subscribeToWatcherUpdates\",\n    value: function _subscribeToWatcherUpdates() {\n      var _this6 = this;\n\n      log2('Subscribed to watcher updates');\n      this._watcherUpdates = this._watcher.subscribe(function (update) {\n        var subject = get(_this6._subjects, update.type);\n\n        if (subject) {\n          var _update$value;\n\n          var logValue = ((_update$value = update.value) === null || _update$value === void 0 ? void 0 : _update$value._isBigNumber) ? \"\".concat(update.value.toString(), \" (BigNumber)\") : update.value;\n          log2('Got watcher update for ' + update.type + ':', logValue);\n\n          _this6._handleResult(subject, update.type, update.value);\n        } else _this6._multicallResultCache[update.type] = update.value;\n      });\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }, {\n    key: \"observableKeys\",\n    get: function get() {\n      return Object.keys(this._schemaByObservableKey);\n    }\n  }, {\n    key: \"watcher\",\n    get: function get() {\n      return this._watcher;\n    }\n  }, {\n    key: \"activeSchemas\",\n    get: function get() {\n      return this._watcher.schemas.filter(function (_ref5) {\n        var id = _ref5.id;\n        return id;\n      }); // Filter only schemas with id\n    }\n  }, {\n    key: \"activeSchemaIds\",\n    get: function get() {\n      return this.activeSchemas.map(function (_ref6) {\n        var id = _ref6.id;\n        return id;\n      });\n    }\n  }, {\n    key: \"totalActiveSchemas\",\n    get: function get() {\n      return this._totalActiveSchemas;\n    }\n  }, {\n    key: \"totalSchemaSubscribers\",\n    get: function get() {\n      return this._totalSchemaSubscribers;\n    }\n  }]);\n\n  return MulticallService;\n}(PublicService);\n\nexport { MulticallService as default };\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(log, \"log\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/MulticallService.js\");\n  reactHotLoader.register(log2, \"log2\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/MulticallService.js\");\n  reactHotLoader.register(throwIfErrorInValues, \"throwIfErrorInValues\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/MulticallService.js\");\n  reactHotLoader.register(checkForErrors, \"checkForErrors\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/MulticallService.js\");\n  reactHotLoader.register(catchNestedErrors, \"catchNestedErrors\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/MulticallService.js\");\n  reactHotLoader.register(MulticallService, \"MulticallService\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/MulticallService.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/MulticallService.js"],"names":["PublicService","createWatcher","debug","Observable","ReplaySubject","combineLatest","from","throwError","timer","map","flatMap","debounceTime","take","catchError","filter","takeUntil","throwIfEmpty","tap","get","set","find","log","log2","throwIfErrorInValues","values","v","Error","checkForErrors","undefined","catchNestedErrors","key","f","err","MulticallService","name","_schemas","_schemaByObservableKey","_schemaInstances","_subjects","_observables","_watcherUpdates","_schemaSubscribers","_totalSchemaSubscribers","_totalActiveSchemas","_multicallResultCache","_addresses","_removeSchemaTimers","settings","addresses","getContractAddresses","_removeSchemaDelay","removeSchemaDelay","_debounceTime","_latestDebounceTime","latestDebounceTime","_latestTimeout","latestTimeout","_connectedAddress","currentAddress","useWeb3Provider","interval","rpcUrl","config","web3","multicallAddress","getContractAddress","onNewBlockPolling","_web3","_watcher","onNewBlock","blockNumber","poll","onPoll","id","block","latestBlockNumber","onError","console","error","cb","start","_flushPendingSchemaRemovals","stop","schemas","Array","isArray","Object","keys","item","forEach","schema","return","returns","ret","length","args","obsPath","join","_watch","depth","throwIfError","pipe","toPromise","schemaDefinition","schemaByObservableKey","expectedArgs","generate","validate","schemaInstance","_createSchemaInstance","computed","existing","result","dependencies","watch","bind","recurseDependencyTree","trie_","trie","slice","Promise","indexesAtLeafNodes","node","allLeafNodes","every","idx","dependencySubs","observable","path","subject","_handleResult","create","observer","_addSchemaToMulticall","_subscribeToWatcherUpdates","sub","subscribe","_removeSchemaFromMulticall","unsubscribe","instancePath","transforms","fullPath","target","contract","call","clearTimeout","calls","process","browser","activeSchemaIds","id_","unsub","setTimeout","_removeSchemaImmediately","schemaTimers","value","_validateResult","next","split","observableKey","hasOwnProperty","update","type","logValue","_isBigNumber","toString","activeSchemas"],"mappings":"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","sourcesContent":["import { PublicService } from '@makerdao/services-core';\nimport { createWatcher } from '@makerdao/multicall';\nimport debug from 'debug';\nimport { Observable, ReplaySubject, combineLatest, from, throwError, timer } from 'rxjs';\nimport {\n  map,\n  flatMap,\n  debounceTime,\n  take,\n  catchError,\n  filter,\n  takeUntil,\n  throwIfEmpty,\n  tap\n} from 'rxjs/operators';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\nimport find from 'lodash/find';\n\nconst log = debug('dai:MulticallService');\nconst log2 = debug('dai:MulticallService:observables');\n\nconst throwIfErrorInValues = values => values.map(v => { if (v instanceof Error) throw v; }); // prettier-ignore\nconst checkForErrors = values => find(values, v => v instanceof Error) === undefined;\nconst catchNestedErrors = key => f =>\n  catchError(err => {\n    log2(`Caught nested error in ${key}: ${err}`);\n    return from([new Error(err)]);\n  })(f);\n\nexport default class MulticallService extends PublicService {\n  constructor(name = 'multicall') {\n    super(name, ['web3', 'smartContract']);\n\n    this._schemas = [];\n    this._schemaByObservableKey = {};\n    this._schemaInstances = {};\n    this._subjects = {};\n    this._observables = {};\n    this._watcherUpdates = null;\n    this._schemaSubscribers = {};\n    this._totalSchemaSubscribers = 0;\n    this._totalActiveSchemas = 0;\n    this._multicallResultCache = {};\n    this._addresses = {};\n    this._removeSchemaTimers = {};\n  }\n\n  initialize(settings = {}) {\n    this._addresses = settings.addresses || this.get('smartContract').getContractAddresses();\n    this._removeSchemaDelay = settings.removeSchemaDelay || 1000;\n    this._debounceTime = settings.debounceTime || 1;\n    this._latestDebounceTime = settings.latestDebounceTime || 1;\n    this._latestTimeout = settings.latestTimeout || 10000;\n  }\n\n  authenticate() {\n    this._connectedAddress = this.get('web3').currentAddress();\n  }\n\n  createWatcher({ useWeb3Provider = false, interval = 'block', rpcUrl, ...config } = {}) {\n    const web3 = this.get('web3');\n    config = {\n      multicallAddress: this.get('smartContract').getContractAddress('MULTICALL'),\n      ...config\n    };\n\n    const onNewBlockPolling = interval === 'block';\n    if (onNewBlockPolling) interval = 60000; // 1 min polling fallback safeguard\n\n    if (useWeb3Provider) config.web3 = web3._web3;\n    else if (!rpcUrl) {\n      if (!web3.rpcUrl) new Error('Unable to get rpcUrl for multicall');\n      rpcUrl = web3.rpcUrl;\n    }\n\n    this._watcher = createWatcher([], { ...config, interval, rpcUrl });\n\n    if (onNewBlockPolling) {\n      log(`Watcher created with poll on new block mode using ${rpcUrl ? `rpcUrl: ${rpcUrl}` : 'web3 provider'}`); // prettier-ignore\n      web3.onNewBlock(blockNumber => {\n        log(`Polling after new block detected (${blockNumber})`);\n        this._watcher.poll();\n      });\n    } else {\n      log(\n        `Watcher created with ${interval}ms polling interval using ${\n          useWeb3Provider ? 'web3 provider' : `rpcUrl: ${rpcUrl}`\n        }`\n      );\n    }\n\n    this._watcher.onPoll(({ id, latestBlockNumber: block }) =>\n      log(`Sending network request #${id}${block ? ` (latest block: ${block})` : ''}`)\n    );\n    this._watcher.onNewBlock(block => log(`Latest block: ${block}`));\n    this._watcher.onError(err => console.error('Multicall error:', err));\n\n    return this._watcher;\n  }\n\n  tap(cb) {\n    log('Watcher tapped');\n    return this._watcher.tap(cb);\n  }\n\n  start() {\n    log('Watcher started');\n    return this._watcher.start();\n  }\n\n  stop() {\n    this._flushPendingSchemaRemovals();\n    log('Watcher stopped');\n    return this._watcher.stop();\n  }\n\n  restart() {\n    this.stop();\n    this.start();\n  }\n\n  schemaByObservableKey(key) {\n    if (!key) throw new Error('Invalid observable key');\n    if (!this._schemaByObservableKey[key])\n      throw new Error(`No registered schema definition found with observable key: ${key}`);\n    return this._schemaByObservableKey[key];\n  }\n\n  get observableKeys() {\n    return Object.keys(this._schemaByObservableKey);\n  }\n\n  get watcher() {\n    return this._watcher;\n  }\n\n  get activeSchemas() {\n    return this._watcher.schemas.filter(({ id }) => id); // Filter only schemas with id\n  }\n\n  get activeSchemaIds() {\n    return this.activeSchemas.map(({ id }) => id);\n  }\n\n  get totalActiveSchemas() {\n    return this._totalActiveSchemas;\n  }\n\n  get totalSchemaSubscribers() {\n    return this._totalSchemaSubscribers;\n  }\n\n  // Register schema definitions\n  registerSchemas(schemas) {\n    if (typeof schemas !== 'object') throw new Error('Schemas must be object or array');\n\n    // If schemas is key/val object use key as schema key and convert to array object\n    if (!Array.isArray(schemas)) schemas = Object.keys(schemas).map(key => ({ key, ...schemas[key] })); // prettier-ignore\n    // Clone if array\n    else schemas = schemas.map(item => ({ ...item }));\n\n    schemas.forEach(schema => {\n      if (!schema.key) throw new Error('Schema definitions must have a unique key');\n      // Automatically use schema key as return key if no return keys specified\n      if (!schema.return && !schema.returns) schema.returns = [schema.key];\n      if (schema.return && schema.returns) throw new Error('Ambiguous return definitions in schema: found both return and returns property'); // prettier-ignore\n      if (schema.return) schema.returns = [schema.return];\n      if (!Array.isArray(schema.returns))\n        throw new Error('Schema must contain return/returns property');\n      // Use return keys to create observable key => schema mapping\n      // and normalize as array of [key, transform] arrays\n      schema.returns = schema.returns.map(ret => {\n        if (!Array.isArray(ret)) ret = [ret];\n        if (this._schemaByObservableKey[ret[0]] !== undefined)\n          throw new Error(`Observable with key ${ret[0]} already registered`);\n        this._schemaByObservableKey[ret[0]] = schema;\n        if (ret.length > 2) throw new Error('Returns array format should be [key, transform]');\n        return ret;\n      });\n    });\n    this._schemas = [...this._schemas, ...schemas];\n    log2(`Registered ${schemas.length} schemas`);\n  }\n\n  latest(key, ...args) {\n    const obsPath = `${key}${args.length > 0 ? '.' : ''}${args.join('.')}`;\n    return this._watch({ depth: 0, throwIfError: true }, key, ...args)\n      .pipe(\n        catchError(err => {\n          throw new Error(err);\n        }),\n        takeUntil(timer(this._latestTimeout)),\n        throwIfEmpty(() => new Error(`Timed out waiting for latest value of: ${obsPath}`)),\n        debounceTime(this._latestDebounceTime),\n        take(1)\n      )\n      .toPromise();\n  }\n\n  watch(key, ...args) {\n    return this._watch({ depth: 0 }, key, ...args);\n  }\n\n  _watch({ depth, throwIfError = false }, key, ...args) {\n    // Find schema definition associated with this observable key\n    const schemaDefinition = this.schemaByObservableKey(key);\n    const expectedArgs = schemaDefinition.generate.length;\n    if (args.length < expectedArgs)\n      return throwError(`Observable ${key} expects at least ${expectedArgs} argument(s)`);\n\n    const obsPath = `${key}${args.length > 0 ? '.' : ''}${args.join('.')}`;\n\n    // Validate arguments using schema args validator\n    if (schemaDefinition?.validate?.args) {\n      const validate = schemaDefinition.validate.args(...args);\n      if (validate) {\n        log2(`Input validation failed for observable: ${obsPath} (depth: ${depth})`);\n        return throwError(validate);\n      }\n    }\n\n    // Create or get existing schema instance for this instance path (schema definition + args)\n    const schemaInstance = this._createSchemaInstance(schemaDefinition, ...args);\n    const { computed } = schemaInstance;\n    log2(`watch() called for ${computed ? 'computed ' : 'base '}observable: ${obsPath} (depth: ${depth})`); // prettier-ignore\n\n    // Return existing observable if one already exists for this observable path (key + args)\n    let existing = get(this._observables, obsPath);\n    if (existing) {\n      if (computed) {\n        log2(`Returning existing computed observable: ${obsPath} (depth: ${depth})`);\n        // Only debounce if call to watch() is not nested\n        if (depth === 0) existing = existing.pipe(debounceTime(this._debounceTime));\n        if (throwIfError) existing = existing.pipe(tap(throwIfErrorInValues));\n        return existing.pipe(\n          // Don't pass values to computed() if any of them are errors\n          filter(checkForErrors),\n          // Pass values to computed() on the computed observable\n          map(result => computed(...result))\n        );\n      }\n      log2(`Returning existing base observable: ${obsPath}`);\n      return existing;\n    }\n\n    // Handle computed observable\n    if (computed) {\n      // Handle dynamically generated dependencies\n      const dependencies =\n        typeof schemaInstance.dependencies === 'function'\n          ? schemaInstance.dependencies({\n              watch: this.watch.bind(this),\n              get: this.get.bind(this)\n            })\n          : schemaInstance.dependencies;\n\n      const recurseDependencyTree = trie_ => {\n        const key = trie_[0];\n        const trie = trie_.slice(1);\n\n        // If the dependency key provided is a function, promise or array of\n        // values then this dependency is providing its own custom value\n        // rather than specifying an existing observable key\n        if (key instanceof Promise || Array.isArray(key)) return from(key);\n        if (typeof key === 'function') return from(key());\n\n        const indexesAtLeafNodes = trie.map(node => !Array.isArray(node));\n        const allLeafNodes = indexesAtLeafNodes.every(node => node === true);\n\n        if (Array.isArray(trie) && trie.length === 0) {\n          // When trie is an empty array, indicates that we only need to return\n          // watch on the key\n          return this._watch({ depth: depth + 1 }, key);\n        } else if (allLeafNodes) {\n          // If the trie is an array it indicates that the observable is\n          // expecting arguments. These can be normal values or other\n          // observables. Where an index in the trie is an array, it is\n          // assumed that it is syntax for an observable argument. In the case\n          // where all indexes in the trie array are normal values, we use the\n          // spread operator to pass them to the returned watch fn\n          return this._watch({ depth: depth + 1 }, key, ...trie);\n        } else {\n          // When a trie array has nested observables, recursively call this fn\n          // on indexes which have an array.\n          return combineLatest(\n            trie.map((node, idx) => {\n              return indexesAtLeafNodes[idx] ? [node] : recurseDependencyTree(node);\n            })\n          ).pipe(\n            flatMap(result =>\n              this._watch({ depth: depth + 1 }, key, ...result).pipe(catchNestedErrors(key))\n            )\n          );\n        }\n      };\n\n      const dependencySubs = dependencies.map(recurseDependencyTree);\n      let observable = combineLatest(dependencySubs);\n\n      log2(`Created new computed observable: ${obsPath} (depth: ${depth})`);\n      set(this._observables, obsPath, observable);\n      // Only debounce if call to watch() is not nested\n      if (depth === 0) observable = observable.pipe(debounceTime(this._debounceTime));\n      if (throwIfError) observable = observable.pipe(tap(throwIfErrorInValues));\n      return observable.pipe(\n        // Don't pass values to computed() if any of them are errors\n        filter(checkForErrors),\n        // Pass values to computed() on the computed observable\n        map(result => computed(...result))\n      );\n    }\n\n    // This is a base observable\n    const { id, path } = schemaInstance;\n    if (this._schemaSubscribers[path] === undefined) this._schemaSubscribers[path] = 0;\n    const subject = new ReplaySubject(1);\n    set(this._subjects, obsPath, subject);\n    // Handle initial value if cached result from multicall exists\n    if (this._multicallResultCache[obsPath] !== undefined)\n      this._handleResult(subject, obsPath, this._multicallResultCache[obsPath]);\n\n    // Create base observable\n    const observable = Observable.create(observer => {\n      this._totalSchemaSubscribers++;\n      log2(`Observer subscribed to ${id} (${this._schemaSubscribers[path] + 1} subscribers)`);\n      // If first subscriber to this schema add it to multicall\n      if (++this._schemaSubscribers[path] === 1) this._addSchemaToMulticall(schemaInstance);\n      // Subscribe to watcher updates and emit them to subjects\n      if (!this._watcherUpdates) this._subscribeToWatcherUpdates();\n      // Subscribe this observer to the subject for this base observable\n      const sub = subject.subscribe(observer);\n      // Return the function to call when this observer unsubscribes\n      return () => {\n        this._totalSchemaSubscribers--;\n        // If last unsubscriber from this schema remove it from multicall\n        if (--this._schemaSubscribers[path] === 0)\n          this._removeSchemaFromMulticall(schemaInstance.id);\n        // Unsubscribe this observer from the subject for this base observable\n        sub.unsubscribe();\n        log2(`Observer unsubscribed from ${id} (${this._schemaSubscribers[path]} subscribers)`); // prettier-ignore\n      };\n    });\n\n    log2(`Created new base observable: ${obsPath}`);\n    set(this._observables, obsPath, observable);\n    return observable;\n  }\n\n  _createSchemaInstance(schemaDefinition, ...args) {\n    const path = args.join('.');\n    const instancePath = `${schemaDefinition.key}${path ? '.' : ''}${path}`;\n\n    // Return existing schema if found for this instance path (schema key + args)\n    if (this._schemaInstances[instancePath]) return this._schemaInstances[instancePath];\n\n    // Generate schema instance\n    const schemaInstance = schemaDefinition.generate(...args);\n    this._schemaInstances[instancePath] = schemaInstance;\n    schemaInstance.args = [...args];\n\n    // Auto generate some fields if this is a base schema\n    if (!schemaInstance.computed) {\n      const { returns, transforms = {} } = schemaInstance;\n      schemaInstance.path = instancePath;\n      // Auto generate return keys for schema instance if not provided by generate()\n      if (!returns) {\n        schemaInstance.returns = schemaDefinition.returns.map(ret => {\n          const key = ret[0];\n          const fullPath = `${key}${path ? '.' : ''}${path}`;\n          return transforms[key]\n            ? [fullPath, transforms[key]] // Use transform mapping in generated schema instance if available\n            : ret.length == 2\n            ? [fullPath, ret[1]]\n            : [fullPath];\n        });\n      }\n      // Resolve target contract address if contract string is provided\n      const { target, contract } = schemaInstance;\n      if (!target && !contract) throw new Error('Schema must specify target address or contract');\n      if (!target && !this._addresses[contract]) throw new Error(`Can't find contract address for ${contract}`); // prettier-ignore\n      schemaInstance.target = target || this._addresses[contract];\n    }\n\n    return schemaInstance;\n  }\n\n  _addSchemaToMulticall(schemaInstance) {\n    const { id, target, call, returns } = schemaInstance;\n    // If schema already added but pending removal then cancel pending removal\n    if (this._removeSchemaTimers[id]) {\n      log2(`Cancelled pending schema removal: ${id}`);\n      clearTimeout(this._removeSchemaTimers[id]);\n      delete this._removeSchemaTimers[id];\n      return;\n    }\n    this._totalActiveSchemas++;\n    this._watcher.tap(calls => [\n      ...calls,\n      {\n        id,\n        target,\n        call,\n        returns\n      }\n    ]);\n    log2(`Schema added to multicall: ${id}`);\n    if (process?.browser) log2('Active schemas (' + this._totalActiveSchemas + ' total):', this.activeSchemaIds);\n    else log2(`Active schemas (${this._totalActiveSchemas} total): ${this.activeSchemaIds.join(',')}`); // prettier-ignore\n  }\n\n  _removeSchemaImmediately(id) {\n    if (this._removeSchemaTimers[id] !== undefined) delete this._removeSchemaTimers[id];\n    log2(`Schema removed from multicall: ${id}`);\n    this._watcher.tap(schemas => schemas.filter(({ id: id_ }) => id_ !== id));\n    // If there are no active schemas unsubscribe from watcher updates\n    if (--this._totalActiveSchemas === 0) {\n      log2('No remaining active schemas');\n      log2('Unsubscribed from watcher updates');\n      this._watcherUpdates.unsub();\n      this._watcherUpdates = null;\n    } else {\n      if (process?.browser) log2('Active schemas (' + this._totalActiveSchemas + ' total):', this.activeSchemaIds);\n      else log2(`Active schemas (${this._totalActiveSchemas} remaining): ${this.activeSchemaIds.join(',')}`); // prettier-ignore\n    }\n  }\n\n  _removeSchemaFromMulticall(id) {\n    this._removeSchemaTimers[id] = setTimeout(\n      () => this._removeSchemaImmediately(id),\n      this._removeSchemaDelay\n    );\n  }\n\n  _flushPendingSchemaRemovals() {\n    const schemaTimers = Object.keys(this._removeSchemaTimers);\n    if (schemaTimers.length === 0) return;\n    log2(`Flushing ${schemaTimers.length} pending schema removals`);\n    for (let id of schemaTimers) {\n      log2(`Forcing schema removal: ${id}`);\n      clearTimeout(this._removeSchemaTimers[id]);\n      this._removeSchemaImmediately(id);\n    }\n  }\n\n  _handleResult(subject, obsPath, value) {\n    const err = this._validateResult(subject, obsPath, value);\n    // Trigger error on observable or emit result value to observable\n    if (err) subject.error(err);\n    else subject.next(value);\n  }\n\n  _validateResult(subject, obsPath, value) {\n    let [observableKey, ...args] = obsPath.split('.');\n    const schemaDefinition = this._schemaByObservableKey[observableKey];\n    const instancePath = `${schemaDefinition.key}${args.length > 0 ? '.' : ''}${args.join('.')}`;\n    const schemaInstance = this._schemaInstances[instancePath];\n    // Pass validation if no validator found for this schema definition\n    if (!schemaDefinition.validate?.hasOwnProperty(observableKey)) return;\n    try {\n      // Call validation func on schema definition for result value and pass schema instance args\n      // as 2nd param and also this context\n      const validate = schemaDefinition.validate[observableKey].call(\n        { args: schemaInstance.args },\n        value,\n        schemaInstance.args\n      );\n      if (validate) throw new Error(validate);\n      return; // Pass validation\n    } catch (err) {\n      log2('Validation error for ' + obsPath + ' result:', value);\n      return err; // Fail validation\n    }\n  }\n\n  _subscribeToWatcherUpdates() {\n    log2('Subscribed to watcher updates');\n    this._watcherUpdates = this._watcher.subscribe(update => {\n      const subject = get(this._subjects, update.type);\n      if (subject) {\n        const logValue = update.value?._isBigNumber\n          ? `${update.value.toString()} (BigNumber)`\n          : update.value;\n        log2('Got watcher update for ' + update.type + ':', logValue);\n        this._handleResult(subject, update.type, update.value);\n      } else this._multicallResultCache[update.type] = update.value;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}