{"ast":null,"code":"import _objectSpread from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _regeneratorRuntime from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { PublicService } from '@makerdao/services-core';\nimport map from 'lodash/fp/map';\nimport omit from 'lodash/fp/omit';\nimport pick from 'lodash/fp/pick';\nimport invariant from 'invariant';\nimport { privateKeyAccountFactory, providerAccountFactory, browserProviderAccountFactory } from './accounts/factories';\nimport { setupEngine } from './accounts/setup';\nimport { AccountType } from '../utils/constants';\nimport assert from 'assert';\nimport debug from 'debug';\nvar log = debug('dai:AccountsService');\nvar sanitizeAccount = pick(['name', 'type', 'address']);\n\nvar AccountsService = /*#__PURE__*/function (_PublicService) {\n  _inherits(AccountsService, _PublicService);\n\n  var _super = _createSuper(AccountsService);\n\n  function AccountsService() {\n    var _this;\n\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'accounts';\n\n    _classCallCheck(this, AccountsService);\n\n    _this = _super.call(this, name, ['event']);\n    _this._accounts = {};\n    _this._accountFactories = {\n      privateKey: privateKeyAccountFactory,\n      provider: providerAccountFactory,\n      browser: browserProviderAccountFactory\n    };\n    return _this;\n  }\n\n  _createClass(AccountsService, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var settings,\n            result,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                settings = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                this._settings = omit('web3', settings);\n                _context.next = 4;\n                return setupEngine(settings);\n\n              case 4:\n                result = _context.sent;\n                this._engine = result.engine;\n                this._provider = result.provider;\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n\n      return initialize;\n    }()\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var accountNames, _i, _accountNames, name;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                accountNames = Object.keys(this._settings);\n                _i = 0, _accountNames = accountNames;\n\n              case 2:\n                if (!(_i < _accountNames.length)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                name = _accountNames[_i];\n                _context2.next = 6;\n                return this.addAccount(name, this._settings[name]);\n\n              case 6:\n                _i++;\n                _context2.next = 2;\n                break;\n\n              case 9:\n                if (!(accountNames.length === 0)) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                _context2.next = 12;\n                return this.addAccount('default', {\n                  type: AccountType.PROVIDER\n                });\n\n              case 12:\n                this._engine.start();\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"getProvider\",\n    value: function getProvider() {\n      return this._engine;\n    }\n  }, {\n    key: \"addAccountType\",\n    value: function addAccountType(type, factory) {\n      invariant(!this._accountFactories[type], \"Account type \\\"\".concat(type, \"\\\" is already defined\"));\n      this._accountFactories[type] = factory;\n    }\n  }, {\n    key: \"addAccount\",\n    value: function () {\n      var _addAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(name) {\n        var options,\n            _options,\n            type,\n            autoSwitch,\n            otherSettings,\n            factory,\n            accountData,\n            account,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n\n                if (name && typeof name !== 'string') {\n                  options = name;\n                  name = null;\n                }\n\n                _options = options, type = _options.type, autoSwitch = _options.autoSwitch, otherSettings = _objectWithoutProperties(_options, [\"type\", \"autoSwitch\"]);\n                invariant(this._engine, 'engine must be set up before adding an account');\n\n                if (!(name && this._accounts[name])) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                throw new Error('An account with this name already exists.');\n\n              case 6:\n                factory = this._accountFactories[type];\n                invariant(factory, \"no factory for type \\\"\".concat(type, \"\\\"\"));\n                _context3.next = 10;\n                return factory(otherSettings, this._provider);\n\n              case 10:\n                accountData = _context3.sent;\n\n                if (accountData.address) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                log(\"Not adding account \\\"\".concat(name, \"\\\" (no address found)\"));\n                return _context3.abrupt(\"return\");\n\n              case 14:\n                accountData.address = accountData.address.toLowerCase();\n\n                if (!this._getAccountWithAddress(accountData.address)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                throw new Error('An account with this address already exists.');\n\n              case 17:\n                if (!name) name = accountData.address;\n                account = _objectSpread({\n                  name: name,\n                  type: type,\n                  autoSwitch: autoSwitch || false\n                }, accountData);\n                this._accounts[name] = account;\n\n                if (!this._currentAccount || name === 'default') {\n                  this.useAccount(name);\n                }\n\n                if (this.hasAccount()) {\n                  this.get('event').emit('accounts/ADD', {\n                    account: sanitizeAccount(account)\n                  });\n                }\n\n                return _context3.abrupt(\"return\", account);\n\n              case 23:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function addAccount(_x) {\n        return _addAccount.apply(this, arguments);\n      }\n\n      return addAccount;\n    }()\n  }, {\n    key: \"listAccounts\",\n    value: function listAccounts() {\n      return map(sanitizeAccount, this._accounts);\n    }\n  }, {\n    key: \"useAccount\",\n    value: function useAccount(name) {\n      var account = this._accounts[name];\n      invariant(account, \"No account found with name \\\"\".concat(name, \"\\\".\"));\n      if (this._autoSwitchCheckHandle) clearInterval(this._autoSwitchCheckHandle);\n\n      if (account.type === AccountType.BROWSER) {\n        assert(isAddressSelected(account.address), 'cannot use a browser account that is not currently selected'); // detect account change and automatically switch active account if\n        // autoSwitch flag set (useful if using a browser wallet like MetaMask)\n        // see: https://github.com/MetaMask/faq/blob/master/DEVELOPERS.md#ear-listening-for-selected-account-changes\n\n        if (account.autoSwitch) {\n          this._autoSwitchCheckHandle = setInterval(this._autoSwitchCheckAccountChange(account.address), 500);\n        }\n      }\n\n      if (this._currentAccount) {\n        this._engine.stop();\n\n        this._engine.removeProvider(this.currentWallet());\n      }\n\n      this._currentAccount = name; // add the provider at index 0 so that it takes precedence over RpcSource\n\n      this._engine.addProvider(this.currentWallet(), 0);\n\n      this._engine.start();\n\n      if (this.hasAccount()) {\n        this.get('event').emit('accounts/CHANGE', {\n          account: this.currentAccount()\n        });\n      }\n    }\n  }, {\n    key: \"_autoSwitchCheckAccountChange\",\n    value: function _autoSwitchCheckAccountChange(addr) {\n      var _this2 = this;\n\n      return /*#__PURE__*/_asyncToGenerator(__signature__( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var activeBrowserAddress;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                activeBrowserAddress = getSelectedAddress().toLowerCase();\n\n                if (!(activeBrowserAddress !== addr)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                if (_this2._getAccountWithAddress(activeBrowserAddress)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                _context4.next = 5;\n                return _this2.addAccount({\n                  type: AccountType.BROWSER,\n                  autoSwitch: true\n                });\n\n              case 5:\n                _this2.useAccountWithAddress(activeBrowserAddress);\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }), \"useAccountWithAddress{}\"));\n    }\n  }, {\n    key: \"_getAccountWithAddress\",\n    value: function _getAccountWithAddress(addr) {\n      var accountObjects = Object.values(this._accounts);\n      return accountObjects.find(function (e) {\n        return e.address.toUpperCase() === addr.toUpperCase();\n      });\n    }\n  }, {\n    key: \"useAccountWithAddress\",\n    value: function useAccountWithAddress(addr) {\n      var account = this._getAccountWithAddress(addr);\n\n      if (!account) throw new Error(\"No account found with address \".concat(addr));\n      this.useAccount(account.name);\n    }\n  }, {\n    key: \"hasAccount\",\n    value: function hasAccount() {\n      return !!this._currentAccount;\n    }\n  }, {\n    key: \"hasNonProviderAccount\",\n    value: function hasNonProviderAccount() {\n      return this.hasAccount() && this.currentAccount().type != AccountType.PROVIDER;\n    } // we intentionally omit subprovider (implementation detail) and privateKey\n    // (sensitive info).\n\n  }, {\n    key: \"currentAccount\",\n    value: function currentAccount() {\n      invariant(this.hasAccount(), 'No account is set up.');\n      return sanitizeAccount(this._accounts[this._currentAccount]);\n    }\n  }, {\n    key: \"currentAddress\",\n    value: function currentAddress() {\n      invariant(this.hasAccount(), 'No account is set up.');\n      return this._accounts[this._currentAccount].address;\n    }\n  }, {\n    key: \"currentWallet\",\n    value: function currentWallet() {\n      return this._accounts[this._currentAccount].subprovider;\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return AccountsService;\n}(PublicService);\n\nexport { AccountsService as default };\n\nfunction getSelectedAddress() {\n  return typeof window.ethereum !== 'undefined' ? window.ethereum.selectedAddress : window.web3.eth.defaultAccount;\n}\n\nfunction isAddressSelected(address) {\n  // if using browser/MetaMask, we must use the currently selected account;\n  // however, it can be blank the first time the user connects their account.\n  var selectedAddress = getSelectedAddress();\n  return !selectedAddress || selectedAddress.toLowerCase() === address;\n}\n\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(log, \"log\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/AccountsService.js\");\n  reactHotLoader.register(sanitizeAccount, \"sanitizeAccount\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/AccountsService.js\");\n  reactHotLoader.register(AccountsService, \"AccountsService\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/AccountsService.js\");\n  reactHotLoader.register(getSelectedAddress, \"getSelectedAddress\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/AccountsService.js\");\n  reactHotLoader.register(isAddressSelected, \"isAddressSelected\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/AccountsService.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/AccountsService.js"],"names":["PublicService","map","omit","pick","invariant","privateKeyAccountFactory","providerAccountFactory","browserProviderAccountFactory","setupEngine","AccountType","assert","debug","log","sanitizeAccount","AccountsService","name","_accounts","_accountFactories","privateKey","provider","browser","settings","_settings","result","_engine","engine","_provider","accountNames","Object","keys","addAccount","length","type","PROVIDER","start","factory","options","autoSwitch","otherSettings","Error","accountData","address","toLowerCase","_getAccountWithAddress","account","_currentAccount","useAccount","hasAccount","get","emit","_autoSwitchCheckHandle","clearInterval","BROWSER","isAddressSelected","setInterval","_autoSwitchCheckAccountChange","stop","removeProvider","currentWallet","addProvider","currentAccount","addr","activeBrowserAddress","getSelectedAddress","useAccountWithAddress","accountObjects","values","find","e","toUpperCase","subprovider","window","ethereum","selectedAddress","web3","eth","defaultAccount"],"mappings":"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","sourcesContent":["import { PublicService } from '@makerdao/services-core';\nimport map from 'lodash/fp/map';\nimport omit from 'lodash/fp/omit';\nimport pick from 'lodash/fp/pick';\nimport invariant from 'invariant';\nimport {\n  privateKeyAccountFactory,\n  providerAccountFactory,\n  browserProviderAccountFactory\n} from './accounts/factories';\nimport { setupEngine } from './accounts/setup';\nimport { AccountType } from '../utils/constants';\nimport assert from 'assert';\nimport debug from 'debug';\nconst log = debug('dai:AccountsService');\n\nconst sanitizeAccount = pick(['name', 'type', 'address']);\n\nexport default class AccountsService extends PublicService {\n  constructor(name = 'accounts') {\n    super(name, ['event']);\n    this._accounts = {};\n    this._accountFactories = {\n      privateKey: privateKeyAccountFactory,\n      provider: providerAccountFactory,\n      browser: browserProviderAccountFactory\n    };\n  }\n\n  async initialize(settings = {}) {\n    this._settings = omit('web3', settings);\n\n    const result = await setupEngine(settings);\n    this._engine = result.engine;\n    this._provider = result.provider;\n  }\n\n  async connect() {\n    const accountNames = Object.keys(this._settings);\n    for (const name of accountNames) {\n      await this.addAccount(name, this._settings[name]);\n    }\n    if (accountNames.length === 0) {\n      await this.addAccount('default', { type: AccountType.PROVIDER });\n    }\n    this._engine.start();\n  }\n\n  getProvider() {\n    return this._engine;\n  }\n\n  addAccountType(type, factory) {\n    invariant(\n      !this._accountFactories[type],\n      `Account type \"${type}\" is already defined`\n    );\n    this._accountFactories[type] = factory;\n  }\n\n  async addAccount(name, options = {}) {\n    if (name && typeof name !== 'string') {\n      options = name;\n      name = null;\n    }\n    const { type, autoSwitch, ...otherSettings } = options;\n    invariant(this._engine, 'engine must be set up before adding an account');\n    if (name && this._accounts[name]) {\n      throw new Error('An account with this name already exists.');\n    }\n    const factory = this._accountFactories[type];\n    invariant(factory, `no factory for type \"${type}\"`);\n    const accountData = await factory(otherSettings, this._provider);\n\n    // TODO allow this to silently fail only in situations where it's expected,\n    // e.g. when connecting to a read-only provider\n    if (!accountData.address) {\n      log(`Not adding account \"${name}\" (no address found)`);\n      return;\n    }\n    accountData.address = accountData.address.toLowerCase();\n\n    if (this._getAccountWithAddress(accountData.address)) {\n      throw new Error('An account with this address already exists.');\n    }\n\n    if (!name) name = accountData.address;\n    const account = {\n      name,\n      type,\n      autoSwitch: autoSwitch || false,\n      ...accountData\n    };\n\n    this._accounts[name] = account;\n    if (!this._currentAccount || name === 'default') {\n      this.useAccount(name);\n    }\n    if (this.hasAccount()) {\n      this.get('event').emit('accounts/ADD', {\n        account: sanitizeAccount(account)\n      });\n    }\n\n    return account;\n  }\n\n  listAccounts() {\n    return map(sanitizeAccount, this._accounts);\n  }\n\n  useAccount(name) {\n    const account = this._accounts[name];\n    invariant(account, `No account found with name \"${name}\".`);\n\n    if (this._autoSwitchCheckHandle) clearInterval(this._autoSwitchCheckHandle);\n\n    if (account.type === AccountType.BROWSER) {\n      assert(\n        isAddressSelected(account.address),\n        'cannot use a browser account that is not currently selected'\n      );\n      // detect account change and automatically switch active account if\n      // autoSwitch flag set (useful if using a browser wallet like MetaMask)\n      // see: https://github.com/MetaMask/faq/blob/master/DEVELOPERS.md#ear-listening-for-selected-account-changes\n      if (account.autoSwitch) {\n        this._autoSwitchCheckHandle = setInterval(\n          this._autoSwitchCheckAccountChange(account.address),\n          500\n        );\n      }\n    }\n\n    if (this._currentAccount) {\n      this._engine.stop();\n      this._engine.removeProvider(this.currentWallet());\n    }\n\n    this._currentAccount = name;\n    // add the provider at index 0 so that it takes precedence over RpcSource\n    this._engine.addProvider(this.currentWallet(), 0);\n    this._engine.start();\n    if (this.hasAccount()) {\n      this.get('event').emit('accounts/CHANGE', {\n        account: this.currentAccount()\n      });\n    }\n  }\n\n  _autoSwitchCheckAccountChange(addr) {\n    return async () => {\n      const activeBrowserAddress = getSelectedAddress().toLowerCase();\n      if (activeBrowserAddress !== addr) {\n        if (!this._getAccountWithAddress(activeBrowserAddress)) {\n          await this.addAccount({\n            type: AccountType.BROWSER,\n            autoSwitch: true\n          });\n        }\n        this.useAccountWithAddress(activeBrowserAddress);\n      }\n    };\n  }\n\n  _getAccountWithAddress(addr) {\n    const accountObjects = Object.values(this._accounts);\n    return accountObjects.find(\n      e => e.address.toUpperCase() === addr.toUpperCase()\n    );\n  }\n\n  useAccountWithAddress(addr) {\n    const account = this._getAccountWithAddress(addr);\n    if (!account) throw new Error(`No account found with address ${addr}`);\n    this.useAccount(account.name);\n  }\n\n  hasAccount() {\n    return !!this._currentAccount;\n  }\n\n  hasNonProviderAccount() {\n    return (\n      this.hasAccount() && this.currentAccount().type != AccountType.PROVIDER\n    );\n  }\n\n  // we intentionally omit subprovider (implementation detail) and privateKey\n  // (sensitive info).\n  currentAccount() {\n    invariant(this.hasAccount(), 'No account is set up.');\n    return sanitizeAccount(this._accounts[this._currentAccount]);\n  }\n\n  currentAddress() {\n    invariant(this.hasAccount(), 'No account is set up.');\n    return this._accounts[this._currentAccount].address;\n  }\n\n  currentWallet() {\n    return this._accounts[this._currentAccount].subprovider;\n  }\n}\n\nfunction getSelectedAddress() {\n  return typeof window.ethereum !== 'undefined'\n    ? window.ethereum.selectedAddress\n    : window.web3.eth.defaultAccount;\n}\n\nfunction isAddressSelected(address) {\n  // if using browser/MetaMask, we must use the currently selected account;\n  // however, it can be blank the first time the user connects their account.\n  const selectedAddress = getSelectedAddress();\n  return !selectedAddress || selectedAddress.toLowerCase() === address;\n}\n"]},"metadata":{},"sourceType":"module"}