{"ast":null,"code":"import _toConsumableArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _applyDecoratedDescriptor from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _asyncToGenerator from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _dec, _dec2, _class;\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { Currency } from '@makerdao/currency';\nimport { LocalService } from '@makerdao/services-core';\nimport tracksTransactions, { tracksTransactionsWithOptions } from './utils/tracksTransactions';\nimport { ServiceRoles } from './constants';\nimport assert from 'assert';\nimport ManagedCdp from './ManagedCdp';\nimport { castAsCurrency, stringToBytes, bytesToString, promiseWait } from './utils';\nimport has from 'lodash/has';\nimport padStart from 'lodash/padStart';\nimport { USDFL, ETH, GNT } from './index';\nimport getEventHistoryImpl from './EventHistory';\nvar CDP_MANAGER = ServiceRoles.CDP_MANAGER,\n    CDP_TYPE = ServiceRoles.CDP_TYPE,\n    SYSTEM_DATA = ServiceRoles.SYSTEM_DATA;\nvar CdpManager = (_dec = tracksTransactionsWithOptions({\n  numArguments: 5\n}), _dec2 = tracksTransactionsWithOptions({\n  numArguments: 5\n}), (_class = /*#__PURE__*/function (_LocalService) {\n  _inherits(CdpManager, _LocalService);\n\n  var _super = _createSuper(CdpManager);\n\n  function CdpManager() {\n    var _this;\n\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CDP_MANAGER;\n\n    _classCallCheck(this, CdpManager);\n\n    _this = _super.call(this, name, ['smartContract', CDP_TYPE, SYSTEM_DATA, 'accounts', 'proxy', 'token', 'web3']);\n    _this._getCdpIdsPromises = {};\n    _this._getUrnPromises = {};\n    return _this;\n  }\n\n  _createClass(CdpManager, [{\n    key: \"getCdpIds\",\n    value: function () {\n      var _getCdpIds = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxyAddress) {\n        var descending,\n            getCdpsMethod,\n            _yield$this$_getCdpId,\n            _yield$this$_getCdpId2,\n            ids,\n            ilks,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                descending = _args.length > 1 && _args[1] !== undefined ? _args[1] : true;\n                getCdpsMethod = descending ? 'getCdpsDesc' : 'getCdpsAsc';\n\n                if (!this._getCdpIdsPromises[proxyAddress]) {\n                  this._getCdpIdsPromises[proxyAddress] = this.get('smartContract').getContract('GET_CDPS') //eslint-disable-next-line no-unexpected-multiline\n                  [getCdpsMethod](this._managerAddress, proxyAddress);\n                }\n\n                _context.next = 5;\n                return this._getCdpIdsPromises[proxyAddress];\n\n              case 5:\n                _yield$this$_getCdpId = _context.sent;\n                _yield$this$_getCdpId2 = _slicedToArray(_yield$this$_getCdpId, 3);\n                ids = _yield$this$_getCdpId2[0];\n                ilks = _yield$this$_getCdpId2[2];\n                assert(ids.length === ilks.length, 'ids and ilks must be the same length');\n                return _context.abrupt(\"return\", ids.map(function (id, index) {\n                  return {\n                    id: id.toNumber(),\n                    ilk: bytesToString(ilks[index])\n                  };\n                }));\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getCdpIds(_x4) {\n        return _getCdpIds.apply(this, arguments);\n      }\n\n      return getCdpIds;\n    }()\n  }, {\n    key: \"getCdp\",\n    value: function () {\n      var _getCdp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(id, options) {\n        var cacheEnabled, cdp, ilk, i;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cacheEnabled = !has(options, 'cache') || options.cache;\n                cdp = this._getFromInstanceCache(id, cacheEnabled);\n\n                if (!cdp) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", cdp);\n\n              case 4:\n                i = 0;\n\n              case 5:\n                if (!(i < 5)) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                _context2.next = 8;\n                return this.getIlkForCdp(id);\n\n              case 8:\n                ilk = _context2.sent;\n\n                if (!ilk) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                return _context2.abrupt(\"break\", 16);\n\n              case 11:\n                _context2.next = 13;\n                return promiseWait(5000);\n\n              case 13:\n                i++;\n                _context2.next = 5;\n                break;\n\n              case 16:\n                cdp = new ManagedCdp(id, ilk, this, options);\n\n                this._putInInstanceCache(id, cdp, cacheEnabled);\n\n                if (!(!has(options, 'prefetch') || options.prefetch)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                _context2.next = 21;\n                return cdp.prefetch();\n\n              case 21:\n                return _context2.abrupt(\"return\", cdp);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getCdp(_x5, _x6) {\n        return _getCdp.apply(this, arguments);\n      }\n\n      return getCdp;\n    }()\n  }, {\n    key: \"getIlkForCdp\",\n    value: function () {\n      var _getIlkForCdp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(id) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = bytesToString;\n                _context3.next = 3;\n                return this._manager.ilks(id);\n\n              case 3:\n                _context3.t1 = _context3.sent;\n                return _context3.abrupt(\"return\", (0, _context3.t0)(_context3.t1));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getIlkForCdp(_x7) {\n        return _getIlkForCdp.apply(this, arguments);\n      }\n\n      return getIlkForCdp;\n    }()\n  }, {\n    key: \"getCombinedDebtValue\",\n    value: function () {\n      var _getCombinedDebtValue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(proxyAddress) {\n        var _this2 = this;\n\n        var descending,\n            ids,\n            debts,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                descending = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : true;\n                _context4.next = 3;\n                return this.getCdpIds(proxyAddress, descending);\n\n              case 3:\n                ids = _context4.sent;\n                _context4.next = 6;\n                return Promise.all(ids.map(function (c) {\n                  var cdp = new ManagedCdp(c.id, c.ilk, _this2);\n                  return cdp.prefetch().then(function () {\n                    return cdp.debtValue;\n                  });\n                }));\n\n              case 6:\n                debts = _context4.sent;\n                return _context4.abrupt(\"return\", debts.reduce(function (a, b) {\n                  return a.plus(b);\n                }));\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getCombinedDebtValue(_x8) {\n        return _getCombinedDebtValue.apply(this, arguments);\n      }\n\n      return getCombinedDebtValue;\n    }()\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(ilk, _ref) {\n        var promise, _ref$cache, cache, proxy, op, cdp;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                promise = _ref.promise, _ref$cache = _ref.cache, cache = _ref$cache === void 0 ? true : _ref$cache;\n                _context5.next = 3;\n                return this.get('proxy').ensureProxy({\n                  promise: promise\n                });\n\n              case 3:\n                proxy = _context5.sent;\n                op = this.proxyActions.open(this._managerAddress, stringToBytes(ilk), proxy, {\n                  dsProxy: true,\n                  promise: promise,\n                  metadata: {\n                    ilk: ilk\n                  }\n                });\n                _context5.t0 = ManagedCdp;\n                _context5.next = 8;\n                return op;\n\n              case 8:\n                _context5.t1 = _context5.sent;\n                _context5.t2 = ilk;\n                _context5.t3 = this;\n                _context5.next = 13;\n                return _context5.t0.create.call(_context5.t0, _context5.t1, _context5.t2, _context5.t3);\n\n              case 13:\n                cdp = _context5.sent;\n\n                this._putInInstanceCache(cdp.id, cdp, cache);\n\n                return _context5.abrupt(\"return\", cdp);\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function open(_x9, _x10) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"reclaimCollateral\",\n    value: function () {\n      var _reclaimCollateral = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(id, dink, _ref2) {\n        var promise;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                promise = _ref2.promise;\n                dink = castAsCurrency(dink, ETH);\n                return _context6.abrupt(\"return\", this.proxyActions.frob(this._managerAddress, this.getIdBytes(id), dink.toFixed('wei'), 0, {\n                  dsProxy: true,\n                  promise: promise,\n                  metadata: {\n                    id: id,\n                    dink: dink\n                  }\n                }));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function reclaimCollateral(_x11, _x12, _x13) {\n        return _reclaimCollateral.apply(this, arguments);\n      }\n\n      return reclaimCollateral;\n    }() // ilk is required if the currency type corresponds to more than one ilk; if\n    // it's omitted, it is inferred from lockAmount's currency type\n\n  }, {\n    key: \"openLockAndDraw\",\n    value: function () {\n      var _openLockAndDraw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(ilk, lockAmount, drawAmount, _ref3) {\n        var promise, _ref3$cache, cache, type, op, cdp;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                promise = _ref3.promise, _ref3$cache = _ref3.cache, cache = _ref3$cache === void 0 ? true : _ref3$cache;\n                type = this.get(CDP_TYPE).getCdpType(lockAmount.type, ilk);\n                op = this.lockAndDraw(null, type.ilk, lockAmount, drawAmount, {\n                  promise: promise\n                });\n                _context7.t0 = ManagedCdp;\n                _context7.next = 6;\n                return op;\n\n              case 6:\n                _context7.t1 = _context7.sent;\n                _context7.t2 = type.ilk;\n                _context7.t3 = this;\n                _context7.next = 11;\n                return _context7.t0.create.call(_context7.t0, _context7.t1, _context7.t2, _context7.t3);\n\n              case 11:\n                cdp = _context7.sent;\n\n                this._putInInstanceCache(cdp.id, cdp, cache);\n\n                return _context7.abrupt(\"return\", cdp);\n\n              case 14:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function openLockAndDraw(_x14, _x15, _x16, _x17) {\n        return _openLockAndDraw.apply(this, arguments);\n      }\n\n      return openLockAndDraw;\n    }()\n  }, {\n    key: \"lockAndDraw\",\n    value: function () {\n      var _lockAndDraw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(id, ilk, lockAmount) {\n        var _this$proxyActions;\n\n        var drawAmount,\n            _ref4,\n            promise,\n            proxyAddress,\n            jugAddress,\n            isEth,\n            isGnt,\n            method,\n            args,\n            _args8 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                drawAmount = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : USDFL(0);\n                _ref4 = _args8.length > 4 ? _args8[4] : undefined, promise = _ref4.promise;\n                assert(lockAmount && drawAmount, 'both amounts must be specified');\n                assert(lockAmount instanceof Currency, 'lockAmount must be a Currency value');\n                drawAmount = castAsCurrency(drawAmount, USDFL);\n                _context8.next = 7;\n                return this.get('proxy').ensureProxy({\n                  promise: promise\n                });\n\n              case 7:\n                proxyAddress = _context8.sent;\n                jugAddress = this.get('smartContract').getContractAddress('MCD_JUG');\n                isEth = ETH.isInstance(lockAmount);\n                isGnt = GNT.isInstance(lockAmount);\n                method = setMethod(isEth, isGnt, id);\n                args = [this._managerAddress, jugAddress, this._adapterAddress(ilk), this._adapterAddress('USDFL'), id || stringToBytes(ilk), !isEth && lockAmount.toFixed(this._precision(lockAmount, ilk)), drawAmount.toFixed('wei'), {\n                  dsProxy: true,\n                  value: isEth ? lockAmount.toFixed('wei') : 0,\n                  promise: promise,\n                  metadata: {\n                    id: id,\n                    ilk: ilk,\n                    lockAmount: lockAmount,\n                    drawAmount: drawAmount\n                  }\n                }].filter(function (x) {\n                  return x;\n                }); // If opening a new GNT CDP, GNT must first be transferred\n                // to the proxy (so it can be transferred to the new bag)\n\n                if (!(method === 'openLockGNTAndDraw')) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                _context8.next = 16;\n                return this.get('token').getToken('GNT').transfer(proxyAddress, lockAmount);\n\n              case 16:\n                if (!(id && isGnt)) {\n                  _context8.next = 19;\n                  break;\n                }\n\n                _context8.next = 19;\n                return transferToBag(lockAmount, proxyAddress, this);\n\n              case 19:\n                // Indicates if gem supports transferFrom\n                if (!isEth && method !== 'openLockGNTAndDraw') args.splice(-1, 0, !GNT.isInstance(lockAmount));\n                _context8.next = 22;\n                return (_this$proxyActions = this.proxyActions)[method].apply(_this$proxyActions, _toConsumableArray(args));\n\n              case 22:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 23:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function lockAndDraw(_x18, _x19, _x20) {\n        return _lockAndDraw.apply(this, arguments);\n      }\n\n      return lockAndDraw;\n    }()\n  }, {\n    key: \"lock\",\n    value: function () {\n      var _lock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(id, ilk, lockAmount, owner, _ref5) {\n        var _this$proxyActions2;\n\n        var promise, proxyAddress, isEth, isGnt, method, args;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                promise = _ref5.promise;\n\n                if (owner) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                _context9.next = 4;\n                return this.getOwner(id);\n\n              case 4:\n                owner = _context9.sent;\n\n              case 5:\n                _context9.next = 7;\n                return this.get('proxy').ensureProxy({\n                  promise: promise\n                });\n\n              case 7:\n                proxyAddress = _context9.sent;\n                isEth = ETH.isInstance(lockAmount);\n                isGnt = GNT.isInstance(lockAmount);\n                method = \"safeLock\".concat(isEth ? 'ETH' : 'Gem');\n                args = [this._managerAddress, this._adapterAddress(ilk), id, !isEth && lockAmount.toFixed(this._precision(lockAmount, ilk)), owner, {\n                  dsProxy: true,\n                  value: isEth ? lockAmount.toFixed('wei') : 0,\n                  promise: promise,\n                  metadata: {\n                    id: id,\n                    ilk: ilk,\n                    lockAmount: lockAmount\n                  }\n                }].filter(function (x) {\n                  return x;\n                }); // Transfers to bag if locking GNT in existing CDP\n\n                if (!(id && isGnt)) {\n                  _context9.next = 15;\n                  break;\n                }\n\n                _context9.next = 15;\n                return transferToBag(lockAmount, proxyAddress, this);\n\n              case 15:\n                // Indicates if gem supports transferFrom\n                if (!isEth) args.splice(-2, 0, !GNT.isInstance(lockAmount));\n                return _context9.abrupt(\"return\", (_this$proxyActions2 = this.proxyActions)[method].apply(_this$proxyActions2, _toConsumableArray(args)));\n\n              case 17:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function lock(_x21, _x22, _x23, _x24, _x25) {\n        return _lock.apply(this, arguments);\n      }\n\n      return lock;\n    }()\n  }, {\n    key: \"draw\",\n    value: function () {\n      var _draw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(id, ilk, drawAmount, _ref6) {\n        var promise;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                promise = _ref6.promise;\n                return _context10.abrupt(\"return\", this.proxyActions.draw(this._managerAddress, this.get('smartContract').getContractAddress('MCD_JUG'), this._adapterAddress('USDFL'), this.getIdBytes(id), castAsCurrency(drawAmount, USDFL).toFixed('wei'), {\n                  dsProxy: true,\n                  promise: promise,\n                  metadata: {\n                    id: id,\n                    ilk: ilk,\n                    drawAmount: drawAmount\n                  }\n                }));\n\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function draw(_x26, _x27, _x28, _x29) {\n        return _draw.apply(this, arguments);\n      }\n\n      return draw;\n    }()\n  }, {\n    key: \"wipeAndFree\",\n    value: function wipeAndFree(id, ilk) {\n      var wipeAmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : USDFL(0);\n      var freeAmount = arguments.length > 3 ? arguments[3] : undefined;\n\n      var _ref7 = arguments.length > 4 ? arguments[4] : undefined,\n          promise = _ref7.promise;\n\n      var isEth = ETH.isInstance(freeAmount);\n      var method = isEth ? 'wipeAndFreeETH' : 'wipeAndFreeGem';\n      return this.proxyActions[method](this._managerAddress, this._adapterAddress(ilk), this._adapterAddress('USDFL'), this.getIdBytes(id), freeAmount.toFixed(this._precision(freeAmount, ilk)), wipeAmount.toFixed('wei'), {\n        dsProxy: true,\n        promise: promise,\n        metadata: {\n          id: id,\n          ilk: ilk,\n          wipeAmount: wipeAmount,\n          freeAmount: freeAmount\n        }\n      });\n    }\n  }, {\n    key: \"wipe\",\n    value: function () {\n      var _wipe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(id, wipeAmount, owner, _ref8) {\n        var promise;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                promise = _ref8.promise;\n\n                if (owner) {\n                  _context11.next = 5;\n                  break;\n                }\n\n                _context11.next = 4;\n                return this.getOwner(id);\n\n              case 4:\n                owner = _context11.sent;\n\n              case 5:\n                return _context11.abrupt(\"return\", this.proxyActions.safeWipe(this._managerAddress, this._adapterAddress('USDFL'), this.getIdBytes(id), wipeAmount.toFixed('wei'), owner, {\n                  dsProxy: true,\n                  promise: promise,\n                  metadata: {\n                    id: id,\n                    wipeAmount: wipeAmount\n                  }\n                }));\n\n              case 6:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function wipe(_x30, _x31, _x32, _x33) {\n        return _wipe.apply(this, arguments);\n      }\n\n      return wipe;\n    }()\n  }, {\n    key: \"unsafeWipe\",\n    value: function unsafeWipe(id, wipeAmount, _ref9) {\n      var promise = _ref9.promise;\n      return this.proxyActions.wipe(this._managerAddress, this._adapterAddress('USDFL'), this.getIdBytes(id), wipeAmount.toFixed('wei'), {\n        dsProxy: true,\n        promise: promise,\n        metadata: {\n          id: id,\n          wipeAmount: wipeAmount\n        }\n      });\n    }\n  }, {\n    key: \"wipeAll\",\n    value: function () {\n      var _wipeAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(id, owner) {\n        var _ref10,\n            promise,\n            _args12 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _ref10 = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : {}, promise = _ref10.promise;\n\n                if (owner) {\n                  _context12.next = 5;\n                  break;\n                }\n\n                _context12.next = 4;\n                return this.getOwner(id);\n\n              case 4:\n                owner = _context12.sent;\n\n              case 5:\n                return _context12.abrupt(\"return\", this.proxyActions.safeWipeAll(this._managerAddress, this._adapterAddress('USDFL'), this.getIdBytes(id), owner, {\n                  dsProxy: true,\n                  promise: promise,\n                  metadata: {\n                    id: id\n                  }\n                }));\n\n              case 6:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function wipeAll(_x34, _x35) {\n        return _wipeAll.apply(this, arguments);\n      }\n\n      return wipeAll;\n    }()\n  }, {\n    key: \"unsafeWipeAll\",\n    value: function unsafeWipeAll(id) {\n      var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          promise = _ref11.promise;\n\n      return this.proxyActions.wipeAll(this._managerAddress, this._adapterAddress('USDFL'), this.getIdBytes(id), {\n        dsProxy: true,\n        promise: promise,\n        metadata: {\n          id: id\n        }\n      });\n    }\n  }, {\n    key: \"wipeAllAndFree\",\n    value: function wipeAllAndFree(id, ilk, freeAmount, _ref12) {\n      var promise = _ref12.promise;\n      var isEth = ETH.isInstance(freeAmount);\n      var method = isEth ? 'wipeAllAndFreeETH' : 'wipeAllAndFreeGem';\n      return this.proxyActions[method](this._managerAddress, this._adapterAddress(ilk), this._adapterAddress('USDFL'), this.getIdBytes(id), freeAmount.toFixed(this._precision(freeAmount, ilk)), {\n        dsProxy: true,\n        promise: promise,\n        metadata: {\n          id: id,\n          ilk: ilk,\n          freeAmount: freeAmount\n        }\n      });\n    } // Gives CDP directly to the supplied address\n\n  }, {\n    key: \"give\",\n    value: function give(id, address, _ref13) {\n      var promise = _ref13.promise;\n      return this.proxyActions.give(this._managerAddress, this.getIdBytes(id), address, {\n        dsProxy: true,\n        promise: promise,\n        metadata: {\n          id: id\n        }\n      });\n    } // Gives CDP to the proxy of the supplied address\n\n  }, {\n    key: \"giveToProxy\",\n    value: function giveToProxy(id, address, _ref14) {\n      var promise = _ref14.promise;\n      return this.proxyActions.giveToProxy(this._contractAddress('PROXY_REGISTRY'), this._managerAddress, this.getIdBytes(id), address, {\n        dsProxy: true,\n        promise: promise,\n        metadata: {\n          id: id,\n          address: address\n        }\n      });\n    }\n  }, {\n    key: \"getUrn\",\n    value: function getUrn(id) {\n      if (!this._getUrnPromises[id]) {\n        this._getUrnPromises[id] = this._manager.urns(id);\n      }\n\n      return this._getUrnPromises[id];\n    }\n  }, {\n    key: \"getOwner\",\n    value: function getOwner(id) {\n      return this._manager.owns(this.getIdBytes(id));\n    }\n  }, {\n    key: \"getIdBytes\",\n    value: function getIdBytes(id) {\n      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      assert(typeof id === 'number', 'ID must be a number');\n      return (prefix ? '0x' : '') + padStart(id.toString(16), 24, '0');\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._getCdpIdsPromises = {};\n      this._getUrnPromises = {};\n    }\n  }, {\n    key: \"_contractAddress\",\n    value: function _contractAddress(name) {\n      return this.get('smartContract').getContractAddress(name);\n    }\n  }, {\n    key: \"_adapterAddress\",\n    value: function _adapterAddress(ilk) {\n      return this.get(SYSTEM_DATA).adapterAddress(ilk);\n    }\n  }, {\n    key: \"_precision\",\n    value: function _precision(amount, ilk) {\n      return amount.type.symbol === 'ETH' ? 'wei' : this.get(CDP_TYPE).getCdpType(amount.type, ilk).decimals;\n    }\n  }, {\n    key: \"_getFromInstanceCache\",\n    value: function _getFromInstanceCache(id, enabled) {\n      if (!enabled) return;\n      if (!this._instanceCache) this._instanceCache = {};\n      var instance = this._instanceCache[id];\n      if (instance) return instance;\n    }\n  }, {\n    key: \"_putInInstanceCache\",\n    value: function _putInInstanceCache(id, instance, enabled) {\n      if (!enabled) return;\n      if (!this._instanceCache) this._instanceCache = {};\n      this._instanceCache[id] = instance;\n    }\n  }, {\n    key: \"getNewCdpId\",\n    value: function getNewCdpId(txo) {\n      var logs = txo.receipt.logs;\n      var managerContract = this.get('smartContract').getContract('CDP_MANAGER');\n\n      var web3 = this.get('web3')._web3;\n\n      var NewCdp = managerContract.interface.events.NewCdp;\n      var topic = web3.utils.keccak256(web3.utils.toHex(NewCdp.signature));\n      var receiptEvent = logs.filter(function (e) {\n        return e.topics[0].toLowerCase() === topic.toLowerCase();\n      });\n      var parsedLog = NewCdp.parse(receiptEvent[0].topics, receiptEvent[0].data);\n      assert(parsedLog['cdp'], 'could not find log for NewCdp event');\n      return parseInt(parsedLog['cdp']);\n    }\n  }, {\n    key: \"getEventHistory\",\n    value: function getEventHistory(managedCdp) {\n      if (!this._eventHistoryCache) this._eventHistoryCache = {};\n      return getEventHistoryImpl(this, managedCdp, this._eventHistoryCache);\n    }\n  }, {\n    key: \"resetEventHistoryCache\",\n    value: function resetEventHistoryCache() {\n      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (id !== null) delete this._eventHistoryCache[id];else this._eventHistoryCache = {};\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }, {\n    key: \"proxyActions\",\n    get: function get() {\n      return this.get('smartContract').getContract('PROXY_ACTIONS');\n    }\n  }, {\n    key: \"vat\",\n    get: function get() {\n      return this.get(SYSTEM_DATA).vat;\n    }\n  }, {\n    key: \"_manager\",\n    get: function get() {\n      return this.get('smartContract').getContract('CDP_MANAGER');\n    }\n  }, {\n    key: \"_managerAddress\",\n    get: function get() {\n      return this._contractAddress('CDP_MANAGER');\n    }\n  }]);\n\n  return CdpManager;\n}(LocalService), (_applyDecoratedDescriptor(_class.prototype, \"open\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"open\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"reclaimCollateral\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"reclaimCollateral\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"openLockAndDraw\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"openLockAndDraw\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"lockAndDraw\", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, \"lockAndDraw\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"lock\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"lock\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"draw\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"draw\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"wipeAndFree\", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, \"wipeAndFree\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"wipe\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"wipe\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"unsafeWipe\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"unsafeWipe\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"wipeAll\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"wipeAll\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"unsafeWipeAll\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"unsafeWipeAll\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"wipeAllAndFree\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"wipeAllAndFree\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"give\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"give\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"giveToProxy\", [tracksTransactions], Object.getOwnPropertyDescriptor(_class.prototype, \"giveToProxy\"), _class.prototype)), _class));\nexport { CdpManager as default };\nexport function setMethod(isEth, isGnt, id) {\n  if (id && isEth) {\n    return 'lockETHAndDraw';\n  } else if (isEth) {\n    return 'openLockETHAndDraw';\n  } else if (!id && isGnt) {\n    return 'openLockGNTAndDraw';\n  } else if (id) {\n    return 'lockGemAndDraw';\n  }\n\n  return 'openLockGemAndDraw';\n}\nexport function transferToBag(_x, _x2, _x3) {\n  return _transferToBag.apply(this, arguments);\n}\n\nfunction _transferToBag() {\n  _transferToBag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(lockAmount, proxyAddress, cdpMgr) {\n    var gntToken, gntAdapter, bagAddress;\n    return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            gntToken = cdpMgr.get('token').getToken(GNT);\n            gntAdapter = cdpMgr.get('smartContract').getContract('MCD_JOIN_GNT_A');\n            _context13.next = 4;\n            return gntAdapter.bags(proxyAddress);\n\n          case 4:\n            bagAddress = _context13.sent;\n            return _context13.abrupt(\"return\", gntToken.transfer(bagAddress, lockAmount));\n\n          case 6:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return _transferToBag.apply(this, arguments);\n}\n\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(CDP_MANAGER, \"CDP_MANAGER\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/CdpManager.js\");\n  reactHotLoader.register(CDP_TYPE, \"CDP_TYPE\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/CdpManager.js\");\n  reactHotLoader.register(SYSTEM_DATA, \"SYSTEM_DATA\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/CdpManager.js\");\n  reactHotLoader.register(CdpManager, \"CdpManager\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/CdpManager.js\");\n  reactHotLoader.register(setMethod, \"setMethod\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/CdpManager.js\");\n  reactHotLoader.register(transferToBag, \"transferToBag\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/CdpManager.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai-plugin-mcd/src/CdpManager.js"],"names":["Currency","LocalService","tracksTransactions","tracksTransactionsWithOptions","ServiceRoles","assert","ManagedCdp","castAsCurrency","stringToBytes","bytesToString","promiseWait","has","padStart","USDFL","ETH","GNT","getEventHistoryImpl","CDP_MANAGER","CDP_TYPE","SYSTEM_DATA","CdpManager","numArguments","name","_getCdpIdsPromises","_getUrnPromises","proxyAddress","descending","getCdpsMethod","get","getContract","_managerAddress","ids","ilks","length","map","id","index","toNumber","ilk","options","cacheEnabled","cache","cdp","_getFromInstanceCache","i","getIlkForCdp","_putInInstanceCache","prefetch","_manager","getCdpIds","Promise","all","c","then","debtValue","debts","reduce","a","b","plus","promise","ensureProxy","proxy","op","proxyActions","open","dsProxy","metadata","create","dink","frob","getIdBytes","toFixed","lockAmount","drawAmount","type","getCdpType","lockAndDraw","jugAddress","getContractAddress","isEth","isInstance","isGnt","method","setMethod","args","_adapterAddress","_precision","value","filter","x","getToken","transfer","transferToBag","splice","owner","getOwner","draw","wipeAmount","freeAmount","safeWipe","wipe","safeWipeAll","wipeAll","address","give","giveToProxy","_contractAddress","urns","owns","prefix","toString","adapterAddress","amount","symbol","decimals","enabled","_instanceCache","instance","txo","logs","receipt","managerContract","web3","_web3","NewCdp","interface","events","topic","utils","keccak256","toHex","signature","receiptEvent","e","topics","toLowerCase","parsedLog","parse","data","parseInt","managedCdp","_eventHistoryCache","vat","cdpMgr","gntToken","gntAdapter","bags","bagAddress"],"mappings":"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","sourcesContent":["import { Currency } from '@makerdao/currency';\nimport { LocalService } from '@makerdao/services-core';\nimport tracksTransactions, {\n  tracksTransactionsWithOptions\n} from './utils/tracksTransactions';\nimport { ServiceRoles } from './constants';\nimport assert from 'assert';\nimport ManagedCdp from './ManagedCdp';\nimport {\n  castAsCurrency,\n  stringToBytes,\n  bytesToString,\n  promiseWait\n} from './utils';\nimport has from 'lodash/has';\nimport padStart from 'lodash/padStart';\nimport { USDFL, ETH, GNT } from './index';\nimport getEventHistoryImpl from './EventHistory';\nconst { CDP_MANAGER, CDP_TYPE, SYSTEM_DATA } = ServiceRoles;\n\nexport default class CdpManager extends LocalService {\n  constructor(name = CDP_MANAGER) {\n    super(name, [\n      'smartContract',\n      CDP_TYPE,\n      SYSTEM_DATA,\n      'accounts',\n      'proxy',\n      'token',\n      'web3'\n    ]);\n    this._getCdpIdsPromises = {};\n    this._getUrnPromises = {};\n  }\n\n  async getCdpIds(proxyAddress, descending = true) {\n    const getCdpsMethod = descending ? 'getCdpsDesc' : 'getCdpsAsc';\n    if (!this._getCdpIdsPromises[proxyAddress]) {\n      this._getCdpIdsPromises[proxyAddress] = this.get('smartContract')\n        .getContract('GET_CDPS')\n        //eslint-disable-next-line no-unexpected-multiline\n        [getCdpsMethod](this._managerAddress, proxyAddress);\n    }\n    const [ids, , ilks] = await this._getCdpIdsPromises[proxyAddress];\n    assert(ids.length === ilks.length, 'ids and ilks must be the same length');\n    return ids.map((id, index) => {\n      return { id: id.toNumber(), ilk: bytesToString(ilks[index]) };\n    });\n  }\n\n  async getCdp(id, options) {\n    const cacheEnabled = !has(options, 'cache') || options.cache;\n    let cdp = this._getFromInstanceCache(id, cacheEnabled);\n    if (cdp) return cdp;\n\n    // This lookup can sometimes miss when a vault is created\n    // causing an assertion error on a missing ilk.\n    let ilk;\n    for (let i = 0; i < 5; i++) {\n      ilk = await this.getIlkForCdp(id);\n      if (ilk) break;\n      await promiseWait(5000);\n    }\n\n    cdp = new ManagedCdp(id, ilk, this, options);\n\n    this._putInInstanceCache(id, cdp, cacheEnabled);\n    if (!has(options, 'prefetch') || options.prefetch) await cdp.prefetch();\n    return cdp;\n  }\n\n  async getIlkForCdp(id) {\n    return bytesToString(await this._manager.ilks(id));\n  }\n\n  async getCombinedDebtValue(proxyAddress, descending = true) {\n    const ids = await this.getCdpIds(proxyAddress, descending);\n    const debts = await Promise.all(\n      ids.map(c => {\n        const cdp = new ManagedCdp(c.id, c.ilk, this);\n        return cdp.prefetch().then(() => cdp.debtValue);\n      })\n    );\n    return debts.reduce((a, b) => a.plus(b));\n  }\n\n  @tracksTransactions\n  async open(ilk, { promise, cache = true }) {\n    const proxy = await this.get('proxy').ensureProxy({ promise });\n    const op = this.proxyActions.open(\n      this._managerAddress,\n      stringToBytes(ilk),\n      proxy,\n      { dsProxy: true, promise, metadata: { ilk } }\n    );\n    const cdp = await ManagedCdp.create(await op, ilk, this);\n    this._putInInstanceCache(cdp.id, cdp, cache);\n    return cdp;\n  }\n\n  @tracksTransactions\n  async reclaimCollateral(id, dink, { promise }) {\n    dink = castAsCurrency(dink, ETH);\n    return this.proxyActions.frob(\n      this._managerAddress,\n      this.getIdBytes(id),\n      dink.toFixed('wei'),\n      0,\n      { dsProxy: true, promise, metadata: { id, dink } }\n    );\n  }\n\n  // ilk is required if the currency type corresponds to more than one ilk; if\n  // it's omitted, it is inferred from lockAmount's currency type\n  @tracksTransactions\n  async openLockAndDraw(\n    ilk,\n    lockAmount,\n    drawAmount,\n    { promise, cache = true }\n  ) {\n    const type = this.get(CDP_TYPE).getCdpType(lockAmount.type, ilk);\n    const op = this.lockAndDraw(null, type.ilk, lockAmount, drawAmount, {\n      promise\n    });\n    const cdp = await ManagedCdp.create(await op, type.ilk, this);\n    this._putInInstanceCache(cdp.id, cdp, cache);\n    return cdp;\n  }\n\n  @tracksTransactionsWithOptions({ numArguments: 5 })\n  async lockAndDraw(id, ilk, lockAmount, drawAmount = USDFL(0), { promise }) {\n    assert(lockAmount && drawAmount, 'both amounts must be specified');\n    assert(\n      lockAmount instanceof Currency,\n      'lockAmount must be a Currency value'\n    );\n    drawAmount = castAsCurrency(drawAmount, USDFL);\n    const proxyAddress = await this.get('proxy').ensureProxy({ promise });\n    const jugAddress = this.get('smartContract').getContractAddress('MCD_JUG');\n    const isEth = ETH.isInstance(lockAmount);\n    const isGnt = GNT.isInstance(lockAmount);\n    const method = setMethod(isEth, isGnt, id);\n    const args = [\n      this._managerAddress,\n      jugAddress,\n      this._adapterAddress(ilk),\n      this._adapterAddress('USDFL'),\n      id || stringToBytes(ilk),\n      !isEth && lockAmount.toFixed(this._precision(lockAmount, ilk)),\n      drawAmount.toFixed('wei'),\n      {\n        dsProxy: true,\n        value: isEth ? lockAmount.toFixed('wei') : 0,\n        promise,\n        metadata: { id, ilk, lockAmount, drawAmount }\n      }\n    ].filter(x => x);\n\n    // If opening a new GNT CDP, GNT must first be transferred\n    // to the proxy (so it can be transferred to the new bag)\n    if (method === 'openLockGNTAndDraw')\n      await this.get('token')\n        .getToken('GNT')\n        .transfer(proxyAddress, lockAmount);\n    // Transfers to bag if locking GNT in existing CDP\n    if (id && isGnt) await transferToBag(lockAmount, proxyAddress, this);\n    // Indicates if gem supports transferFrom\n    if (!isEth && method !== 'openLockGNTAndDraw')\n      args.splice(-1, 0, !GNT.isInstance(lockAmount));\n\n    return await this.proxyActions[method](...args);\n  }\n\n  @tracksTransactions\n  async lock(id, ilk, lockAmount, owner, { promise }) {\n    if (!owner) owner = await this.getOwner(id);\n    const proxyAddress = await this.get('proxy').ensureProxy({ promise });\n    const isEth = ETH.isInstance(lockAmount);\n    const isGnt = GNT.isInstance(lockAmount);\n    const method = `safeLock${isEth ? 'ETH' : 'Gem'}`;\n    const args = [\n      this._managerAddress,\n      this._adapterAddress(ilk),\n      id,\n      !isEth && lockAmount.toFixed(this._precision(lockAmount, ilk)),\n      owner,\n      {\n        dsProxy: true,\n        value: isEth ? lockAmount.toFixed('wei') : 0,\n        promise,\n        metadata: { id, ilk, lockAmount }\n      }\n    ].filter(x => x);\n\n    // Transfers to bag if locking GNT in existing CDP\n    if (id && isGnt) await transferToBag(lockAmount, proxyAddress, this);\n    // Indicates if gem supports transferFrom\n    if (!isEth) args.splice(-2, 0, !GNT.isInstance(lockAmount));\n\n    return this.proxyActions[method](...args);\n  }\n\n  @tracksTransactions\n  async draw(id, ilk, drawAmount, { promise }) {\n    return this.proxyActions.draw(\n      this._managerAddress,\n      this.get('smartContract').getContractAddress('MCD_JUG'),\n      this._adapterAddress('USDFL'),\n      this.getIdBytes(id),\n      castAsCurrency(drawAmount, USDFL).toFixed('wei'),\n      { dsProxy: true, promise, metadata: { id, ilk, drawAmount } }\n    );\n  }\n\n  @tracksTransactionsWithOptions({ numArguments: 5 })\n  wipeAndFree(id, ilk, wipeAmount = USDFL(0), freeAmount, { promise }) {\n    const isEth = ETH.isInstance(freeAmount);\n    const method = isEth ? 'wipeAndFreeETH' : 'wipeAndFreeGem';\n    return this.proxyActions[method](\n      this._managerAddress,\n      this._adapterAddress(ilk),\n      this._adapterAddress('USDFL'),\n      this.getIdBytes(id),\n      freeAmount.toFixed(this._precision(freeAmount, ilk)),\n      wipeAmount.toFixed('wei'),\n      { dsProxy: true, promise, metadata: { id, ilk, wipeAmount, freeAmount } }\n    );\n  }\n\n  @tracksTransactions\n  async wipe(id, wipeAmount, owner, { promise }) {\n    if (!owner) owner = await this.getOwner(id);\n    return this.proxyActions.safeWipe(\n      this._managerAddress,\n      this._adapterAddress('USDFL'),\n      this.getIdBytes(id),\n      wipeAmount.toFixed('wei'),\n      owner,\n      { dsProxy: true, promise, metadata: { id, wipeAmount } }\n    );\n  }\n\n  @tracksTransactions\n  unsafeWipe(id, wipeAmount, { promise }) {\n    return this.proxyActions.wipe(\n      this._managerAddress,\n      this._adapterAddress('USDFL'),\n      this.getIdBytes(id),\n      wipeAmount.toFixed('wei'),\n      { dsProxy: true, promise, metadata: { id, wipeAmount } }\n    );\n  }\n\n  @tracksTransactions\n  async wipeAll(id, owner, { promise } = {}) {\n    if (!owner) owner = await this.getOwner(id);\n    return this.proxyActions.safeWipeAll(\n      this._managerAddress,\n      this._adapterAddress('USDFL'),\n      this.getIdBytes(id),\n      owner,\n      { dsProxy: true, promise, metadata: { id } }\n    );\n  }\n\n  @tracksTransactions\n  unsafeWipeAll(id, { promise } = {}) {\n    return this.proxyActions.wipeAll(\n      this._managerAddress,\n      this._adapterAddress('USDFL'),\n      this.getIdBytes(id),\n      { dsProxy: true, promise, metadata: { id } }\n    );\n  }\n\n  @tracksTransactions\n  wipeAllAndFree(id, ilk, freeAmount, { promise }) {\n    const isEth = ETH.isInstance(freeAmount);\n    const method = isEth ? 'wipeAllAndFreeETH' : 'wipeAllAndFreeGem';\n    return this.proxyActions[method](\n      this._managerAddress,\n      this._adapterAddress(ilk),\n      this._adapterAddress('USDFL'),\n      this.getIdBytes(id),\n      freeAmount.toFixed(this._precision(freeAmount, ilk)),\n      { dsProxy: true, promise, metadata: { id, ilk, freeAmount } }\n    );\n  }\n\n  // Gives CDP directly to the supplied address\n  @tracksTransactions\n  give(id, address, { promise }) {\n    return this.proxyActions.give(\n      this._managerAddress,\n      this.getIdBytes(id),\n      address,\n      { dsProxy: true, promise, metadata: { id } }\n    );\n  }\n\n  // Gives CDP to the proxy of the supplied address\n  @tracksTransactions\n  giveToProxy(id, address, { promise }) {\n    return this.proxyActions.giveToProxy(\n      this._contractAddress('PROXY_REGISTRY'),\n      this._managerAddress,\n      this.getIdBytes(id),\n      address,\n      { dsProxy: true, promise, metadata: { id, address } }\n    );\n  }\n\n  getUrn(id) {\n    if (!this._getUrnPromises[id]) {\n      this._getUrnPromises[id] = this._manager.urns(id);\n    }\n    return this._getUrnPromises[id];\n  }\n\n  getOwner(id) {\n    return this._manager.owns(this.getIdBytes(id));\n  }\n\n  getIdBytes(id, prefix = true) {\n    assert(typeof id === 'number', 'ID must be a number');\n    return (prefix ? '0x' : '') + padStart(id.toString(16), 24, '0');\n  }\n\n  get proxyActions() {\n    return this.get('smartContract').getContract('PROXY_ACTIONS');\n  }\n\n  get vat() {\n    return this.get(SYSTEM_DATA).vat;\n  }\n\n  reset() {\n    this._getCdpIdsPromises = {};\n    this._getUrnPromises = {};\n  }\n\n  get _manager() {\n    return this.get('smartContract').getContract('CDP_MANAGER');\n  }\n\n  get _managerAddress() {\n    return this._contractAddress('CDP_MANAGER');\n  }\n\n  _contractAddress(name) {\n    return this.get('smartContract').getContractAddress(name);\n  }\n\n  _adapterAddress(ilk) {\n    return this.get(SYSTEM_DATA).adapterAddress(ilk);\n  }\n\n  _precision(amount, ilk) {\n    return amount.type.symbol === 'ETH'\n      ? 'wei'\n      : this.get(CDP_TYPE).getCdpType(amount.type, ilk).decimals;\n  }\n\n  _getFromInstanceCache(id, enabled) {\n    if (!enabled) return;\n    if (!this._instanceCache) this._instanceCache = {};\n    const instance = this._instanceCache[id];\n    if (instance) return instance;\n  }\n\n  _putInInstanceCache(id, instance, enabled) {\n    if (!enabled) return;\n    if (!this._instanceCache) this._instanceCache = {};\n    this._instanceCache[id] = instance;\n  }\n\n  getNewCdpId(txo) {\n    const logs = txo.receipt.logs;\n    const managerContract = this.get('smartContract').getContract(\n      'CDP_MANAGER'\n    );\n    const web3 = this.get('web3')._web3;\n    const { NewCdp } = managerContract.interface.events;\n    const topic = web3.utils.keccak256(web3.utils.toHex(NewCdp.signature));\n    const receiptEvent = logs.filter(\n      e => e.topics[0].toLowerCase() === topic.toLowerCase()\n    );\n    const parsedLog = NewCdp.parse(\n      receiptEvent[0].topics,\n      receiptEvent[0].data\n    );\n    assert(parsedLog['cdp'], 'could not find log for NewCdp event');\n    return parseInt(parsedLog['cdp']);\n  }\n\n  getEventHistory(managedCdp) {\n    if (!this._eventHistoryCache) this._eventHistoryCache = {};\n    return getEventHistoryImpl(this, managedCdp, this._eventHistoryCache);\n  }\n\n  resetEventHistoryCache(id = null) {\n    if (id !== null) delete this._eventHistoryCache[id];\n    else this._eventHistoryCache = {};\n  }\n}\n\nexport function setMethod(isEth, isGnt, id) {\n  if (id && isEth) {\n    return 'lockETHAndDraw';\n  } else if (isEth) {\n    return 'openLockETHAndDraw';\n  } else if (!id && isGnt) {\n    return 'openLockGNTAndDraw';\n  } else if (id) {\n    return 'lockGemAndDraw';\n  }\n  return 'openLockGemAndDraw';\n}\n\nexport async function transferToBag(lockAmount, proxyAddress, cdpMgr) {\n  const gntToken = cdpMgr.get('token').getToken(GNT);\n  const gntAdapter = cdpMgr.get('smartContract').getContract('MCD_JOIN_GNT_A');\n  const bagAddress = await gntAdapter.bags(proxyAddress);\n\n  return gntToken.transfer(bagAddress, lockAmount);\n}\n"]},"metadata":{},"sourceType":"module"}