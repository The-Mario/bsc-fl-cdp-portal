{"ast":null,"code":"\"use strict\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _StateMachine = _interopRequireDefault(require(\"./StateMachine\"));\n\nvar _ServiceState = _interopRequireDefault(require(\"./ServiceState\"));\n\nvar _ServiceType = _interopRequireWildcard(require(\"./ServiceType\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar log = (0, _debug[\"default\"])('dai:ServiceManagerBase');\n\nfunction _promisify(unsafeCallback) {\n  return new Promise(function (resolve, reject) {\n    try {\n      resolve(unsafeCallback());\n    } catch (e) {\n      reject(e.message);\n    }\n  });\n}\n\nvar ServiceManagerBase = /*#__PURE__*/function () {\n  /**\n   * @param init {function|null}\n   * @param connect {function|null}\n   * @param auth {function|null}\n   */\n  function ServiceManagerBase() {\n    var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var connect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var auth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    (0, _classCallCheck2[\"default\"])(this, ServiceManagerBase); // Validate init\n\n    if (init !== null && typeof init !== 'function') {\n      throw new Error('Invalid argument init: not a function or null.');\n    } else if (init === null) {\n      init = function init() {\n        return Promise.resolve();\n      };\n    } // Validate connect\n\n\n    if (connect !== null && typeof connect !== 'function') {\n      throw new Error('Invalid argument connect: not a function or null.');\n    } else if (connect === null && auth !== null) {\n      connect = function connect() {\n        return Promise.resolve();\n      };\n    } // Validate auth\n\n\n    if (auth !== null && typeof auth !== 'function') {\n      throw new Error('Invalid argument auth: not a function or null.');\n    } // Set initial props\n\n\n    this._init = init;\n    this._connect = connect;\n    this._auth = auth;\n    this._type = auth === null ? connect === null ? _ServiceType[\"default\"].LOCAL : _ServiceType[\"default\"].PUBLIC : _ServiceType[\"default\"].PRIVATE;\n    this._state = new _StateMachine[\"default\"](_ServiceState[\"default\"].CREATED, _ServiceType.serviceTypeTransitions[this._type]);\n    this._initPromise = null;\n    this._connectPromise = null;\n    this._authPromise = null;\n  }\n  /**\n   * @returns {Promise}\n   */\n\n\n  (0, _createClass2[\"default\"])(ServiceManagerBase, [{\n    key: \"initialize\",\n    value: function initialize(settings) {\n      var _this = this; // If our current state is preceding the INITIALIZING state, we need to set up initialization\n\n\n      if (this._state.inState(_ServiceState[\"default\"].CREATED)) {\n        // Assert that there is no initPromise at this point\n\n        /* istanbul ignore next */\n        if (this._initPromise) {\n          throw new Error('Unexpected init promise in state CREATED.');\n        } // Enter the INITIALIZING state\n\n\n        this._state.transitionTo(_ServiceState[\"default\"].INITIALIZING); // After trying to initialize, transition to the success state (READY/OFFLINE) or revert to CREATED\n\n\n        this._initPromise = _promisify(function () {\n          return _this._init(settings);\n        }).then(function () {\n          return _this._state.transitionTo(_this._type === _ServiceType[\"default\"].LOCAL ? _ServiceState[\"default\"].READY : _ServiceState[\"default\"].OFFLINE);\n        }, function (reason) {\n          log(reason);\n\n          _this._state.transitionTo(_ServiceState[\"default\"].CREATED);\n\n          throw reason;\n        });\n      }\n\n      return this._initPromise;\n    }\n    /**\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this; // Local Services are 'connected' whenever they are initialized\n\n\n      if (this._type === _ServiceType[\"default\"].LOCAL) {\n        return this.initialize();\n      } // If our current state is preceding the CONNECTING state, we need to set up a new connection\n\n\n      if (this._state.inState([_ServiceState[\"default\"].CREATED, _ServiceState[\"default\"].INITIALIZING, _ServiceState[\"default\"].OFFLINE]) && this._connectPromise === null) {\n        // Make sure to be initialized before trying to connect\n        this._connectPromise = this.initialize().then(function () {\n          // Enter the CONNECTING state\n          _this2._state.transitionTo(_ServiceState[\"default\"].CONNECTING); // After trying to connect, transition to the success state (ONLINE/READY) or revert to OFFLINE.\n\n\n          return _promisify(function () {\n            return _this2._connect(function () {\n              return _this2._disconnect();\n            });\n          }).then(function () {\n            // Check if we are still CONNECTING, because another process might have come in between\n            if (_this2._state.inState(_ServiceState[\"default\"].CONNECTING)) {\n              _this2._state.transitionTo(_this2._type === _ServiceType[\"default\"].PUBLIC ? _ServiceState[\"default\"].READY : _ServiceState[\"default\"].ONLINE);\n            }\n          }, function (error) {\n            log('connect error:', error); // Check if we are still CONNECTING, because another process might have come in between\n\n            if (_this2._state.inState(_ServiceState[\"default\"].CONNECTING)) {\n              _this2._state.transitionTo(_ServiceState[\"default\"].OFFLINE);\n            }\n\n            throw error;\n          });\n        });\n      }\n\n      return this._connectPromise;\n    }\n    /**\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"authenticate\",\n    value: function authenticate() {\n      var _this3 = this; // Public and Local Services are 'authenticated' whenever they are connected (/initialized)\n\n\n      if (this._type !== _ServiceType[\"default\"].PRIVATE) {\n        return this.connect();\n      } // If our current state is preceding the AUTHENTICATING state, we need to set up a new authentication\n\n\n      if (this._state.inState([_ServiceState[\"default\"].CREATED, _ServiceState[\"default\"].INITIALIZING, _ServiceState[\"default\"].OFFLINE, _ServiceState[\"default\"].CONNECTING, _ServiceState[\"default\"].ONLINE]) && this._authPromise === null) {\n        // Make sure to be connected before trying to authenticate\n        this._authPromise = this.connect().then(function () {\n          // Enter the AUTHENTICATING state\n          _this3._state.transitionTo(_ServiceState[\"default\"].AUTHENTICATING); // After trying to authenticate, transition to the success state (READY) or revert to ONLINE\n\n\n          return _promisify(function () {\n            return _this3._auth(function () {\n              return _this3._deauthenticate();\n            });\n          }).then(function () {\n            // Check if we are still AUTHENTICATING, because another process might have come in between\n            // (Most notably, a disconnect may have transitioned us into OFFLINE state).\n            if (_this3._state.inState(_ServiceState[\"default\"].AUTHENTICATING)) {\n              _this3._state.transitionTo(_ServiceState[\"default\"].READY);\n            }\n          }, function (reason) {\n            log('authenticate error: ' + reason); // Check if we are still AUTHENTICATING, because another process might have come in between\n\n            if (_this3._state.inState(_ServiceState[\"default\"].AUTHENTICATING)) {\n              _this3._state.transitionTo(_ServiceState[\"default\"].ONLINE);\n            }\n          });\n        });\n      }\n\n      return this._authPromise;\n    }\n    /**\n     * @returns { ServiceManagerBase }\n     */\n\n  }, {\n    key: \"settings\",\n    value: function settings(_settings) {\n      this._settings = _settings;\n      return this;\n    }\n    /**\n     * @returns {string}\n     */\n\n  }, {\n    key: \"state\",\n    value: function state() {\n      return this._state.state();\n    }\n    /**\n     * @returns {string}\n     */\n\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this._type;\n    }\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return !this._state.inState([_ServiceState[\"default\"].CREATED, _ServiceState[\"default\"].INITIALIZING]);\n    }\n    /**\n     * @returns {boolean|null}\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this._type === _ServiceType[\"default\"].LOCAL ? null : this._state.inState([_ServiceState[\"default\"].ONLINE, _ServiceState[\"default\"].AUTHENTICATING, _ServiceState[\"default\"].READY]);\n    }\n    /**\n     * @returns {boolean|null}\n     */\n\n  }, {\n    key: \"isAuthenticated\",\n    value: function isAuthenticated() {\n      return this._type === _ServiceType[\"default\"].PRIVATE ? this._state.inState(_ServiceState[\"default\"].READY) : null;\n    }\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isReady\",\n    value: function isReady() {\n      return this._state.inState(_ServiceState[\"default\"].READY);\n    }\n    /**\n     * @param {function} handler\n     * @returns {ServiceManagerBase}\n     */\n\n  }, {\n    key: \"onInitialized\",\n    value: function onInitialized(handler) {\n      this._state.onStateChanged(function (oldState, newState) {\n        if (oldState === _ServiceState[\"default\"].INITIALIZING && (newState === _ServiceState[\"default\"].OFFLINE || newState === _ServiceState[\"default\"].READY)) {\n          handler();\n        }\n      });\n\n      return this;\n    }\n    /**\n     * @param {function} handler\n     * @returns {ServiceManagerBase}\n     */\n\n  }, {\n    key: \"onConnected\",\n    value: function onConnected(handler) {\n      this._state.onStateChanged(function (oldState, newState) {\n        if (oldState === _ServiceState[\"default\"].CONNECTING && (newState === _ServiceState[\"default\"].ONLINE || newState === _ServiceState[\"default\"].READY)) {\n          handler();\n        }\n      });\n\n      return this;\n    }\n    /**\n     * @param {function} handler\n     * @returns {ServiceManagerBase}\n     */\n\n  }, {\n    key: \"onDisconnected\",\n    value: function onDisconnected(handler) {\n      this._state.onStateChanged(function (oldState, newState) {\n        if (newState === _ServiceState[\"default\"].OFFLINE && (oldState === _ServiceState[\"default\"].ONLINE || oldState === _ServiceState[\"default\"].READY)) {\n          handler();\n        }\n      });\n\n      return this;\n    }\n    /**\n     * @param {function} handler\n     * @returns {ServiceManagerBase}\n     */\n\n  }, {\n    key: \"onAuthenticated\",\n    value: function onAuthenticated(handler) {\n      this._state.onStateChanged(function (oldState, newState) {\n        if (oldState === _ServiceState[\"default\"].AUTHENTICATING && newState === _ServiceState[\"default\"].READY) {\n          handler();\n        }\n      });\n\n      return this;\n    }\n    /**\n     * @param {function} handler\n     * @returns {ServiceManagerBase}\n     */\n\n  }, {\n    key: \"onDeauthenticated\",\n    value: function onDeauthenticated(handler) {\n      if (this.type() === _ServiceType[\"default\"].PRIVATE) {\n        this._state.onStateChanged(function (oldState, newState) {\n          if ((newState === _ServiceState[\"default\"].OFFLINE || newState === _ServiceState[\"default\"].ONLINE) && oldState === _ServiceState[\"default\"].READY) {\n            handler();\n          }\n        });\n      }\n\n      return this;\n    }\n    /**\n     * @param {function} handler\n     * @returns {ServiceManagerBase}\n     */\n\n  }, {\n    key: \"onReady\",\n    value: function onReady(handler) {\n      this._state.onStateChanged(function (_, newState) {\n        if (newState === _ServiceState[\"default\"].READY) {\n          handler();\n        }\n      });\n\n      return this;\n    }\n    /**\n     * @param {function} handler\n     * @returns {ServiceManagerBase}\n     */\n\n  }, {\n    key: \"onStateChanged\",\n    value: function onStateChanged(handler) {\n      this._state.onStateChanged(handler);\n\n      return this;\n    }\n    /**\n     * This is called by the service implementation object, which is the only authority with knowledge on the true\n     * connection status. This will e.g. get called when a ping signal is no longer returned by the back-end and the\n     * service implementation object concludes that we are therefore offline.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_disconnect\",\n    value: function _disconnect() {\n      /* istanbul ignore next */\n      if (this._type === _ServiceType[\"default\"].LOCAL) {\n        throw new Error('_disconnect must not be called on a Local Service');\n      }\n\n      if (this._state.inState(_ServiceState[\"default\"].AUTHENTICATING)) {\n        this._deauthenticate();\n      }\n\n      if (this._state.inState([_ServiceState[\"default\"].READY, _ServiceState[\"default\"].ONLINE, _ServiceState[\"default\"].CONNECTING])) {\n        this._authPromise = null;\n        this._connectPromise = null;\n\n        this._state.transitionTo(_ServiceState[\"default\"].OFFLINE);\n      }\n    }\n    /**\n     * This is called by the service implementation object, which is the only authority with knowledge on the true\n     * authentication status. This will e.g. get called when an authentication token expires or a user logs out, and the\n     * service implementation object concludes that we are therefore no longer authenticated.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_deauthenticate\",\n    value: function _deauthenticate() {\n      /* istanbul ignore next */\n      if (this._type !== _ServiceType[\"default\"].PRIVATE) {\n        throw new Error('_deauthenticate must not be called on a Local or Public Service');\n      }\n\n      if (this._state.inState([_ServiceState[\"default\"].READY, _ServiceState[\"default\"].AUTHENTICATING])) {\n        this._authPromise = null;\n\n        this._state.transitionTo(_ServiceState[\"default\"].ONLINE);\n      }\n    }\n  }]);\n  return ServiceManagerBase;\n}();\n\nvar _default = ServiceManagerBase;\nexports[\"default\"] = _default;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(_classCallCheck2, \"_classCallCheck2\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(_createClass2, \"_createClass2\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(_StateMachine, \"_StateMachine\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(_ServiceState, \"_ServiceState\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(_ServiceType, \"_ServiceType\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(_debug, \"_debug\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(log, \"log\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(_promisify, \"_promisify\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(ServiceManagerBase, \"ServiceManagerBase\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n  reactHotLoader.register(_default, \"_default\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/@makerdao/services-core/dist/ServiceManagerBase.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"script"}