{"ast":null,"code":"'use strict';\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar FilterSubprovider = require('./filters.js');\n\nvar from = require('../util/rpc-hex-encoding.js');\n\nvar inherits = require('util').inherits;\n\nvar utils = require('ethereumjs-util');\n\nfunction SubscriptionSubprovider(opts) {\n  var self = this;\n  opts = opts || {};\n  EventEmitter.apply(this, Array.prototype.slice.call(arguments));\n  FilterSubprovider.apply(this, [opts]);\n  this.subscriptions = {};\n}\n\ninherits(SubscriptionSubprovider, FilterSubprovider); // a cheap crack at multiple inheritance\n// I don't really care if `instanceof EventEmitter` passes...\n\nObject.assign(SubscriptionSubprovider.prototype, EventEmitter.prototype); // preserve our constructor, though\n\nSubscriptionSubprovider.prototype.constructor = SubscriptionSubprovider;\n\nSubscriptionSubprovider.prototype.eth_subscribe = function (payload, cb) {\n  var self = this;\n\n  var createSubscriptionFilter = function createSubscriptionFilter() {};\n\n  var subscriptionType = payload.params[0];\n\n  switch (subscriptionType) {\n    case 'logs':\n      var options = payload.params[1];\n      createSubscriptionFilter = self.newLogFilter.bind(self, options);\n      break;\n\n    case 'newPendingTransactions':\n      createSubscriptionFilter = self.newPendingTransactionFilter.bind(self);\n      break;\n\n    case 'newHeads':\n      createSubscriptionFilter = self.newBlockFilter.bind(self);\n      break;\n\n    case 'syncing':\n    default:\n      cb(new Error('unsupported subscription type'));\n      return;\n  }\n\n  createSubscriptionFilter(function (err, hexId) {\n    if (err) return cb(err);\n    var id = Number.parseInt(hexId, 16);\n    self.subscriptions[id] = subscriptionType;\n    self.filters[id].on('data', function (results) {\n      if (!Array.isArray(results)) {\n        results = [results];\n      }\n\n      var notificationHandler = self._notificationHandler.bind(self, hexId, subscriptionType);\n\n      results.forEach(notificationHandler);\n      self.filters[id].clearChanges();\n    });\n\n    if (subscriptionType === 'newPendingTransactions') {\n      self.checkForPendingBlocks();\n    }\n\n    cb(null, hexId);\n  });\n};\n\nSubscriptionSubprovider.prototype.eth_unsubscribe = function (payload, cb) {\n  var self = this;\n  var hexId = payload.params[0];\n  var id = Number.parseInt(hexId, 16);\n\n  if (!self.subscriptions[id]) {\n    cb(new Error('Subscription ID ' + hexId + ' not found.'));\n  } else {\n    var subscriptionType = self.subscriptions[id];\n    self.uninstallFilter(hexId, function (err, result) {\n      delete self.subscriptions[id];\n      cb(err, result);\n    });\n  }\n};\n\nSubscriptionSubprovider.prototype._notificationHandler = function (hexId, subscriptionType, result) {\n  var self = this;\n\n  if (subscriptionType === 'newHeads') {\n    result = self._notificationResultFromBlock(result);\n  } // it seems that web3 doesn't expect there to be a separate error event\n  // so we must emit null along with the result object\n\n\n  self.emit('data', null, {\n    jsonrpc: \"2.0\",\n    method: \"eth_subscription\",\n    params: {\n      subscription: hexId,\n      result: result\n    }\n  });\n};\n\nSubscriptionSubprovider.prototype._notificationResultFromBlock = function (block) {\n  return {\n    hash: utils.bufferToHex(block.hash),\n    parentHash: utils.bufferToHex(block.parentHash),\n    sha3Uncles: utils.bufferToHex(block.sha3Uncles),\n    miner: utils.bufferToHex(block.miner),\n    stateRoot: utils.bufferToHex(block.stateRoot),\n    transactionsRoot: utils.bufferToHex(block.transactionsRoot),\n    receiptsRoot: utils.bufferToHex(block.receiptsRoot),\n    logsBloom: utils.bufferToHex(block.logsBloom),\n    difficulty: from.bufferToQuantityHex(block.difficulty),\n    number: from.bufferToQuantityHex(block.number),\n    gasLimit: from.bufferToQuantityHex(block.gasLimit),\n    gasUsed: from.bufferToQuantityHex(block.gasUsed),\n    nonce: block.nonce ? utils.bufferToHex(block.nonce) : null,\n    timestamp: from.bufferToQuantityHex(block.timestamp),\n    extraData: utils.bufferToHex(block.extraData)\n  };\n};\n\nSubscriptionSubprovider.prototype.handleRequest = function (payload, next, end) {\n  switch (payload.method) {\n    case 'eth_subscribe':\n      this.eth_subscribe(payload, end);\n      break;\n\n    case 'eth_unsubscribe':\n      this.eth_unsubscribe(payload, end);\n      break;\n\n    default:\n      FilterSubprovider.prototype.handleRequest.apply(this, Array.prototype.slice.call(arguments));\n  }\n};\n\nmodule.exports = SubscriptionSubprovider;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(EventEmitter, \"EventEmitter\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js\");\n  reactHotLoader.register(inherits, \"inherits\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js\");\n  reactHotLoader.register(SubscriptionSubprovider, \"SubscriptionSubprovider\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"script"}