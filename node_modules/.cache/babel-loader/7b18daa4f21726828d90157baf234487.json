{"ast":null,"code":"import _regeneratorRuntime from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport times from 'lodash/times';\n/*\n\nThe default export is a decorator definition.\n\nIf a function is decorated with `@tracksTransactions`, it should expect its last\nargument to be an object with a key named `promise`. It should pass that\n`promise` argument along as a key in the last argument to any non-constant\nfunction calls it makes to a smart contract (i.e. an instance returned from the\ngetContract method in SmartContractService), or any calls it makes to other\nfunctions that will eventually call such smart contract functions.\n\nThis allows TransactionManager to let users input a promise and attach lifecycle\ncallbacks to all transactions that were created in the course of executing that\npromise.\n\n@tracksTransactions is only necessary when the function is async. If the\nfunction returns a contract call and does not make any async calls before that,\nthen the async keyword can be removed, and it just needs to have an `options`\nargument that it passes to its contract call.\n\nIf you need to apply this to a function that has any arguments with default\nvalues, use `@tracksTransactionsWithOptions({ numArguments })` instead, where\n`numArguments` is the total number of arguments to the function, including the\nlast object which contains a key named `promise`.\n\n*/\n\nvar tracksTransactions = tracksTransactionsWithOptions({});\nvar _default = tracksTransactions;\nexport default _default;\nexport function tracksTransactionsWithOptions(_ref) {\n  var numArguments = _ref.numArguments;\n  return function (target, name, descriptor) {\n    var original = descriptor.value;\n    var correctArgsLength = numArguments || original.length;\n\n    descriptor.value = function () {\n      var _this = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var last = args[args.length - 1];\n      var options;\n\n      if (typeof last === 'object' && last !== null && last.constructor === Object) {\n        args = args.slice(0, args.length - 1);\n        options = last;\n      } else {\n        options = {};\n      }\n\n      var promise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var newArgs;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return 0;\n\n              case 2:\n                // if there's already a promise, reuse it instead of setting this one--\n                // this allows the function we're running to behave differently when\n                // it's called directly vs. by another function. e.g. lockWeth\n                if (!options.promise) options.promise = promise; // pad the list of arguments with `undefined` to account for any missing\n                // ones with default values.\n\n                newArgs = [].concat(_toConsumableArray(args), _toConsumableArray(times(correctArgsLength - 1 - args.length, function () {\n                  return undefined;\n                })), [options]);\n                return _context.abrupt(\"return\", original.apply(_this, newArgs));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n\n      return promise;\n    };\n\n    return descriptor;\n  };\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(tracksTransactions, \"tracksTransactions\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/utils/tracksTransactions.js\");\n  reactHotLoader.register(tracksTransactionsWithOptions, \"tracksTransactionsWithOptions\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/utils/tracksTransactions.js\");\n  reactHotLoader.register(_default, \"default\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/utils/tracksTransactions.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/utils/tracksTransactions.js"],"names":["times","tracksTransactions","tracksTransactionsWithOptions","numArguments","target","name","descriptor","original","value","correctArgsLength","length","args","last","options","constructor","Object","slice","promise","newArgs","undefined","apply"],"mappings":";;;;;;;;;;;;;AAAA,OAAOA,KAAP,MAAkB,cAAlB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,IAAMC,kBAAkB,GAAGC,6BAA6B,CAAC,EAAD,CAAxD;eACeD,kB;AAAf;AAEA,OAAO,SAASC,6BAAT,OAAyD;AAAA,MAAhBC,YAAgB,QAAhBA,YAAgB;AAC9D,SAAO,UAACC,MAAD,EAASC,IAAT,EAAeC,UAAf,EAA8B;AACnC,QAAMC,QAAQ,GAAGD,UAAU,CAACE,KAA5B;AACA,QAAMC,iBAAiB,GAAGN,YAAY,IAAII,QAAQ,CAACG,MAAnD;;AACAJ,IAAAA,UAAU,CAACE,KAAX,GAAmB,YAAkB;AAAA;;AAAA,wCAANG,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACnC,UAAMC,IAAI,GAAGD,IAAI,CAACA,IAAI,CAACD,MAAL,GAAc,CAAf,CAAjB;AACA,UAAIG,OAAJ;;AACA,UACE,OAAOD,IAAP,KAAgB,QAAhB,IACAA,IAAI,KAAK,IADT,IAEAA,IAAI,CAACE,WAAL,KAAqBC,MAHvB,EAIE;AACAJ,QAAAA,IAAI,GAAGA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcL,IAAI,CAACD,MAAL,GAAc,CAA5B,CAAP;AACAG,QAAAA,OAAO,GAAGD,IAAV;AACD,OAPD,MAOO;AACLC,QAAAA,OAAO,GAAG,EAAV;AACD;;AAED,UAAMI,OAAO,GAAG,yDAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAGT,CAHS;;AAAA;AAKf;AACA;AACA;AACA,oBAAI,CAACJ,OAAO,CAACI,OAAb,EAAsBJ,OAAO,CAACI,OAAR,GAAkBA,OAAlB,CARP,CAUf;AACA;;AACMC,gBAAAA,OAZS,gCAaVP,IAbU,sBAcVX,KAAK,CAACS,iBAAiB,GAAG,CAApB,GAAwBE,IAAI,CAACD,MAA9B,EAAsC;AAAA,yBAAMS,SAAN;AAAA,iBAAtC,CAdK,IAebN,OAfa;AAAA,iDAiBRN,QAAQ,CAACa,KAAT,CAAe,KAAf,EAAqBF,OAArB,CAjBQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,IAAhB;;AAmBA,aAAOD,OAAP;AACD,KAlCD;;AAmCA,WAAOX,UAAP;AACD,GAvCD;AAwCD;;;;;;;;;;0BA5CKL,kB;0BAGUC,6B","sourcesContent":["import times from 'lodash/times';\n\n/*\n\nThe default export is a decorator definition.\n\nIf a function is decorated with `@tracksTransactions`, it should expect its last\nargument to be an object with a key named `promise`. It should pass that\n`promise` argument along as a key in the last argument to any non-constant\nfunction calls it makes to a smart contract (i.e. an instance returned from the\ngetContract method in SmartContractService), or any calls it makes to other\nfunctions that will eventually call such smart contract functions.\n\nThis allows TransactionManager to let users input a promise and attach lifecycle\ncallbacks to all transactions that were created in the course of executing that\npromise.\n\n@tracksTransactions is only necessary when the function is async. If the\nfunction returns a contract call and does not make any async calls before that,\nthen the async keyword can be removed, and it just needs to have an `options`\nargument that it passes to its contract call.\n\nIf you need to apply this to a function that has any arguments with default\nvalues, use `@tracksTransactionsWithOptions({ numArguments })` instead, where\n`numArguments` is the total number of arguments to the function, including the\nlast object which contains a key named `promise`.\n\n*/\n\nconst tracksTransactions = tracksTransactionsWithOptions({});\nexport default tracksTransactions;\n\nexport function tracksTransactionsWithOptions({ numArguments }) {\n  return (target, name, descriptor) => {\n    const original = descriptor.value;\n    const correctArgsLength = numArguments || original.length;\n    descriptor.value = function(...args) {\n      const last = args[args.length - 1];\n      let options;\n      if (\n        typeof last === 'object' &&\n        last !== null &&\n        last.constructor === Object\n      ) {\n        args = args.slice(0, args.length - 1);\n        options = last;\n      } else {\n        options = {};\n      }\n\n      const promise = (async () => {\n        // this \"no-op await\" is necessary for the inner reference to the\n        // outer promise to become valid.\n        await 0;\n\n        // if there's already a promise, reuse it instead of setting this one--\n        // this allows the function we're running to behave differently when\n        // it's called directly vs. by another function. e.g. lockWeth\n        if (!options.promise) options.promise = promise;\n\n        // pad the list of arguments with `undefined` to account for any missing\n        // ones with default values.\n        const newArgs = [\n          ...args,\n          ...times(correctArgsLength - 1 - args.length, () => undefined),\n          options\n        ];\n        return original.apply(this, newArgs);\n      })();\n      return promise;\n    };\n    return descriptor;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}