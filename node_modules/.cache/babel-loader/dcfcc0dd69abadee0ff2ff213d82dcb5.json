{"ast":null,"code":"import _regeneratorRuntime from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport ethUtil from 'ethereumjs-util';\nimport Wallet from 'web3-provider-engine/dist/es5/subproviders/wallet';\nimport { getBrowserProvider } from './setup';\nimport assert from 'assert';\nexport function privateKeyAccountFactory(_ref) {\n  var key = _ref.key;\n\n  if (typeof key != 'string' || !key.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error('Invalid private key format');\n  }\n\n  var _ref2 = key.startsWith('0x') ? [key, key.replace(/^0x/, '')] : ['0x' + key, key],\n      _ref3 = _slicedToArray(_ref2, 2),\n      keyWithPrefix = _ref3[0],\n      keySansPrefix = _ref3[1];\n\n  var address = '0x' + ethUtil.privateToAddress(keyWithPrefix).toString('hex');\n  var keyBuffer = Buffer.from(keySansPrefix, 'hex');\n  var subprovider = new Wallet({\n    getAddressString: function getAddressString() {\n      return address;\n    },\n    getPrivateKey: function getPrivateKey() {\n      return keyBuffer;\n    }\n  }, {});\n  return {\n    subprovider: subprovider,\n    address: address\n  };\n}\n\nfunction getAccountAddress(_x) {\n  return _getAccountAddress.apply(this, arguments);\n}\n\nfunction _getAccountAddress() {\n  _getAccountAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(subprovider) {\n    var _ref5,\n        _ref5$offset,\n        offset,\n        address,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref5 = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, _ref5$offset = _ref5.offset, offset = _ref5$offset === void 0 ? 0 : _ref5$offset, address = _ref5.address;\n            assert(!(offset && address), 'Cannot set both address and offset');\n            return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n              return subprovider.handleRequest({\n                method: 'eth_accounts',\n                params: [],\n                id: 1\n              }, null, function (err, val) {\n                if (err) return reject(err);\n\n                if (address) {\n                  var matchingAddress = val.find(function (a) {\n                    return a.toLowerCase() === address.toLowerCase();\n                  });\n                  assert(matchingAddress, 'No matching address found in provider.');\n                  resolve(matchingAddress.toLowerCase());\n                } else {\n                  resolve(typeof val[offset] === 'string' ? val[offset].toLowerCase() : val[offset]);\n                }\n              });\n            }));\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getAccountAddress.apply(this, arguments);\n}\n\nexport function providerAccountFactory(_x2, _x3) {\n  return _providerAccountFactory.apply(this, arguments);\n}\n\nfunction _providerAccountFactory() {\n  _providerAccountFactory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref4, provider) {\n    var offset, address, subprovider;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            offset = _ref4.offset, address = _ref4.address;\n            // we need to be able to swap out this account while leaving the original\n            // provider in place for other accounts, so the subprovider here has to be\n            // a different instance. using Proxy is a simple way to accomplish this.\n            subprovider = new Proxy(provider, {});\n            _context2.t0 = subprovider;\n            _context2.next = 5;\n            return getAccountAddress(subprovider, {\n              offset: offset,\n              address: address\n            });\n\n          case 5:\n            _context2.t1 = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              subprovider: _context2.t0,\n              address: _context2.t1\n            });\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _providerAccountFactory.apply(this, arguments);\n}\n\nexport function browserProviderAccountFactory() {\n  return _browserProviderAccountFactory.apply(this, arguments);\n}\n\nfunction _browserProviderAccountFactory() {\n  _browserProviderAccountFactory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var subprovider;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return getBrowserProvider();\n\n          case 2:\n            subprovider = _context3.sent;\n            _context3.t0 = subprovider;\n            _context3.next = 6;\n            return getAccountAddress(subprovider);\n\n          case 6:\n            _context3.t1 = _context3.sent;\n            return _context3.abrupt(\"return\", {\n              subprovider: _context3.t0,\n              address: _context3.t1\n            });\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _browserProviderAccountFactory.apply(this, arguments);\n}\n\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(privateKeyAccountFactory, \"privateKeyAccountFactory\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/accounts/factories.js\");\n  reactHotLoader.register(getAccountAddress, \"getAccountAddress\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/accounts/factories.js\");\n  reactHotLoader.register(providerAccountFactory, \"providerAccountFactory\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/accounts/factories.js\");\n  reactHotLoader.register(browserProviderAccountFactory, \"browserProviderAccountFactory\", \"/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/accounts/factories.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/good/Documents/Good/GitHub/FL/fork/bsc-fl-cdp-portal/src/libs/dai/src/eth/accounts/factories.js"],"names":["ethUtil","Wallet","getBrowserProvider","assert","privateKeyAccountFactory","key","match","Error","startsWith","replace","keyWithPrefix","keySansPrefix","address","privateToAddress","toString","keyBuffer","Buffer","from","subprovider","getAddressString","getPrivateKey","getAccountAddress","offset","Promise","resolve","reject","handleRequest","method","params","id","err","val","matchingAddress","find","a","toLowerCase","providerAccountFactory","provider","Proxy","browserProviderAccountFactory"],"mappings":"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","sourcesContent":["import ethUtil from 'ethereumjs-util';\nimport Wallet from 'web3-provider-engine/dist/es5/subproviders/wallet';\nimport { getBrowserProvider } from './setup';\nimport assert from 'assert';\n\nexport function privateKeyAccountFactory({ key }) {\n  if (typeof key != 'string' || !key.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error('Invalid private key format');\n  }\n\n  const [keyWithPrefix, keySansPrefix] = key.startsWith('0x')\n    ? [key, key.replace(/^0x/, '')]\n    : ['0x' + key, key];\n\n  const address =\n    '0x' + ethUtil.privateToAddress(keyWithPrefix).toString('hex');\n  const keyBuffer = Buffer.from(keySansPrefix, 'hex');\n\n  const subprovider = new Wallet(\n    { getAddressString: () => address, getPrivateKey: () => keyBuffer },\n    {}\n  );\n\n  return { subprovider, address };\n}\n\nasync function getAccountAddress(subprovider, { offset = 0, address } = {}) {\n  assert(!(offset && address), 'Cannot set both address and offset');\n\n  return new Promise((resolve, reject) =>\n    subprovider.handleRequest(\n      { method: 'eth_accounts', params: [], id: 1 },\n      null,\n      (err, val) => {\n        if (err) return reject(err);\n        if (address) {\n          const matchingAddress = val.find(\n            a => a.toLowerCase() === address.toLowerCase()\n          );\n          assert(matchingAddress, 'No matching address found in provider.');\n          resolve(matchingAddress.toLowerCase());\n        } else {\n          resolve(\n            typeof val[offset] === 'string'\n              ? val[offset].toLowerCase()\n              : val[offset]\n          );\n        }\n      }\n    )\n  );\n}\n\nexport async function providerAccountFactory({ offset, address }, provider) {\n  // we need to be able to swap out this account while leaving the original\n  // provider in place for other accounts, so the subprovider here has to be\n  // a different instance. using Proxy is a simple way to accomplish this.\n  const subprovider = new Proxy(provider, {});\n  return {\n    subprovider,\n    address: await getAccountAddress(subprovider, { offset, address })\n  };\n}\n\nexport async function browserProviderAccountFactory() {\n  const subprovider = await getBrowserProvider();\n  return { subprovider, address: await getAccountAddress(subprovider) };\n}\n"]},"metadata":{},"sourceType":"module"}